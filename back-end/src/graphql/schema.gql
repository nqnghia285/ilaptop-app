# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateComment {
  _avg: CommentAvgAggregate
  _count: CommentCountAggregate
  _max: CommentMaxAggregate
  _min: CommentMinAggregate
  _sum: CommentSumAggregate
}

type AggregateCustomer {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
}

type AggregateDiscount {
  _avg: DiscountAvgAggregate
  _count: DiscountCountAggregate
  _max: DiscountMaxAggregate
  _min: DiscountMinAggregate
  _sum: DiscountSumAggregate
}

type AggregateLaptop {
  _avg: LaptopAvgAggregate
  _count: LaptopCountAggregate
  _max: LaptopMaxAggregate
  _min: LaptopMinAggregate
  _sum: LaptopSumAggregate
}

type AggregatePassage {
  _avg: PassageAvgAggregate
  _count: PassageCountAggregate
  _max: PassageMaxAggregate
  _min: PassageMinAggregate
  _sum: PassageSumAggregate
}

type AggregatePerson {
  _count: PersonCountAggregate
  _max: PersonMaxAggregate
  _min: PersonMinAggregate
}

type AggregatePost {
  _avg: PostAvgAggregate
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
  _sum: PostSumAggregate
}

type AggregatePriceMap {
  _avg: PriceMapAvgAggregate
  _count: PriceMapCountAggregate
  _max: PriceMapMaxAggregate
  _min: PriceMapMinAggregate
  _sum: PriceMapSumAggregate
}

type AggregatePurchase {
  _avg: PurchaseAvgAggregate
  _count: PurchaseCountAggregate
  _max: PurchaseMaxAggregate
  _min: PurchaseMinAggregate
  _sum: PurchaseSumAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type Comment {
  _count: CommentCount
  author: Person!
  authorId: String!
  author_id: String!
  comment: Comment
  commentId: Int
  comment_id: Float!
  comments(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  content: String!
  createdAt: Timestamp!
  created_at: Timestamp!
  id: Int!
  isStaff: Boolean!
  is_staff: Boolean!
  laptop: Laptop!
  laptopId: Int!
  laptop_id: Float!
  rank: Rank!
  updatedAt: Timestamp!
  updated_at: Timestamp!
}

type CommentAvgAggregate {
  commentId: Float
  id: Float
  laptopId: Float
}

input CommentAvgOrderByAggregateInput {
  commentId: SortOrder
  id: SortOrder
  laptopId: SortOrder
}

type CommentCount {
  comments: Int!
}

type CommentCountAggregate {
  _all: Int!
  authorId: Int!
  commentId: Int!
  content: Int!
  createdAt: Int!
  id: Int!
  isStaff: Int!
  laptopId: Int!
  rank: Int!
  updatedAt: Int!
}

input CommentCountOrderByAggregateInput {
  authorId: SortOrder
  commentId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  isStaff: SortOrder
  laptopId: SortOrder
  rank: SortOrder
  updatedAt: SortOrder
}

input CommentCreateInput {
  author: PersonCreateNestedOneWithoutCommentsInput!
  comment: CommentCreateNestedOneWithoutCommentsInput
  comments: CommentCreateNestedManyWithoutCommentInput
  content: String!
  createdAt: Timestamp
  isStaff: Boolean
  laptop: LaptopCreateNestedOneWithoutCommentsInput!
  rank: Rank
  updatedAt: Timestamp
}

input CommentCreateManyAuthorInput {
  commentId: Int
  content: String!
  createdAt: Timestamp
  id: Int
  isStaff: Boolean
  laptopId: Int!
  rank: Rank
  updatedAt: Timestamp
}

input CommentCreateManyAuthorInputEnvelope {
  data: [CommentCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyCommentInput {
  authorId: String!
  content: String!
  createdAt: Timestamp
  id: Int
  isStaff: Boolean
  laptopId: Int!
  rank: Rank
  updatedAt: Timestamp
}

input CommentCreateManyCommentInputEnvelope {
  data: [CommentCreateManyCommentInput!]!
  skipDuplicates: Boolean
}

input CommentCreateManyInput {
  authorId: String!
  commentId: Int
  content: String!
  createdAt: Timestamp
  id: Int
  isStaff: Boolean
  laptopId: Int!
  rank: Rank
  updatedAt: Timestamp
}

input CommentCreateManyLaptopInput {
  authorId: String!
  commentId: Int
  content: String!
  createdAt: Timestamp
  id: Int
  isStaff: Boolean
  rank: Rank
  updatedAt: Timestamp
}

input CommentCreateManyLaptopInputEnvelope {
  data: [CommentCreateManyLaptopInput!]!
  skipDuplicates: Boolean
}

input CommentCreateNestedManyWithoutAuthorInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutAuthorInput!]
  create: [CommentCreateWithoutAuthorInput!]
  createMany: CommentCreateManyAuthorInputEnvelope
}

input CommentCreateNestedManyWithoutCommentInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutCommentInput!]
  create: [CommentCreateWithoutCommentInput!]
  createMany: CommentCreateManyCommentInputEnvelope
}

input CommentCreateNestedManyWithoutLaptopInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutLaptopInput!]
  create: [CommentCreateWithoutLaptopInput!]
  createMany: CommentCreateManyLaptopInputEnvelope
}

input CommentCreateNestedOneWithoutCommentsInput {
  connect: CommentWhereUniqueInput
  connectOrCreate: CommentCreateOrConnectWithoutCommentsInput
  create: CommentCreateWithoutCommentsInput
}

input CommentCreateOrConnectWithoutAuthorInput {
  create: CommentCreateWithoutAuthorInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateOrConnectWithoutCommentInput {
  create: CommentCreateWithoutCommentInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateOrConnectWithoutCommentsInput {
  create: CommentCreateWithoutCommentsInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateOrConnectWithoutLaptopInput {
  create: CommentCreateWithoutLaptopInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateWithoutAuthorInput {
  comment: CommentCreateNestedOneWithoutCommentsInput
  comments: CommentCreateNestedManyWithoutCommentInput
  content: String!
  createdAt: Timestamp
  isStaff: Boolean
  laptop: LaptopCreateNestedOneWithoutCommentsInput!
  rank: Rank
  updatedAt: Timestamp
}

input CommentCreateWithoutCommentInput {
  author: PersonCreateNestedOneWithoutCommentsInput!
  comments: CommentCreateNestedManyWithoutCommentInput
  content: String!
  createdAt: Timestamp
  isStaff: Boolean
  laptop: LaptopCreateNestedOneWithoutCommentsInput!
  rank: Rank
  updatedAt: Timestamp
}

input CommentCreateWithoutCommentsInput {
  author: PersonCreateNestedOneWithoutCommentsInput!
  comment: CommentCreateNestedOneWithoutCommentsInput
  content: String!
  createdAt: Timestamp
  isStaff: Boolean
  laptop: LaptopCreateNestedOneWithoutCommentsInput!
  rank: Rank
  updatedAt: Timestamp
}

input CommentCreateWithoutLaptopInput {
  author: PersonCreateNestedOneWithoutCommentsInput!
  comment: CommentCreateNestedOneWithoutCommentsInput
  comments: CommentCreateNestedManyWithoutCommentInput
  content: String!
  createdAt: Timestamp
  isStaff: Boolean
  rank: Rank
  updatedAt: Timestamp
}

type CommentGroupBy {
  _avg: CommentAvgAggregate
  _count: CommentCountAggregate
  _max: CommentMaxAggregate
  _min: CommentMinAggregate
  _sum: CommentSumAggregate
  authorId: String!
  commentId: Int
  content: String!
  createdAt: Timestamp!
  id: Int!
  isStaff: Boolean!
  laptopId: Int!
  rank: Rank!
  updatedAt: Timestamp!
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

type CommentMaxAggregate {
  authorId: String
  commentId: Int
  content: String
  createdAt: Timestamp
  id: Int
  isStaff: Boolean
  laptopId: Int
  rank: Rank
  updatedAt: Timestamp
}

input CommentMaxOrderByAggregateInput {
  authorId: SortOrder
  commentId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  isStaff: SortOrder
  laptopId: SortOrder
  rank: SortOrder
  updatedAt: SortOrder
}

type CommentMinAggregate {
  authorId: String
  commentId: Int
  content: String
  createdAt: Timestamp
  id: Int
  isStaff: Boolean
  laptopId: Int
  rank: Rank
  updatedAt: Timestamp
}

input CommentMinOrderByAggregateInput {
  authorId: SortOrder
  commentId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  isStaff: SortOrder
  laptopId: SortOrder
  rank: SortOrder
  updatedAt: SortOrder
}

input CommentOrderByRelationAggregateInput {
  _count: SortOrder
}

input CommentOrderByWithAggregationInput {
  _avg: CommentAvgOrderByAggregateInput
  _count: CommentCountOrderByAggregateInput
  _max: CommentMaxOrderByAggregateInput
  _min: CommentMinOrderByAggregateInput
  _sum: CommentSumOrderByAggregateInput
  authorId: SortOrder
  commentId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  isStaff: SortOrder
  laptopId: SortOrder
  rank: SortOrder
  updatedAt: SortOrder
}

input CommentOrderByWithRelationInput {
  author: PersonOrderByWithRelationInput
  authorId: SortOrder
  comment: CommentOrderByWithRelationInput
  commentId: SortOrder
  comments: CommentOrderByRelationAggregateInput
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  isStaff: SortOrder
  laptop: LaptopOrderByWithRelationInput
  laptopId: SortOrder
  rank: SortOrder
  updatedAt: SortOrder
}

input CommentRelationFilter {
  is: CommentWhereInput
  isNot: CommentWhereInput
}

enum CommentScalarFieldEnum {
  authorId
  commentId
  content
  createdAt
  id
  isStaff
  laptopId
  rank
  updatedAt
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  authorId: StringFilter
  commentId: IntNullableFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  isStaff: BoolFilter
  laptopId: IntFilter
  rank: EnumRankFilter
  updatedAt: DateTimeFilter
}

input CommentScalarWhereWithAggregatesInput {
  AND: [CommentScalarWhereWithAggregatesInput!]
  NOT: [CommentScalarWhereWithAggregatesInput!]
  OR: [CommentScalarWhereWithAggregatesInput!]
  authorId: StringWithAggregatesFilter
  commentId: IntNullableWithAggregatesFilter
  content: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  isStaff: BoolWithAggregatesFilter
  laptopId: IntWithAggregatesFilter
  rank: EnumRankWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type CommentSumAggregate {
  commentId: Int
  id: Int
  laptopId: Int
}

input CommentSumOrderByAggregateInput {
  commentId: SortOrder
  id: SortOrder
  laptopId: SortOrder
}

input CommentUpdateInput {
  author: PersonUpdateOneRequiredWithoutCommentsInput
  comment: CommentUpdateOneWithoutCommentsInput
  comments: CommentUpdateManyWithoutCommentInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  isStaff: BoolFieldUpdateOperationsInput
  laptop: LaptopUpdateOneRequiredWithoutCommentsInput
  rank: EnumRankFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  isStaff: BoolFieldUpdateOperationsInput
  rank: EnumRankFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateManyWithWhereWithoutAuthorInput {
  data: CommentUpdateManyMutationInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithWhereWithoutCommentInput {
  data: CommentUpdateManyMutationInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithWhereWithoutLaptopInput {
  data: CommentUpdateManyMutationInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithoutAuthorInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutAuthorInput!]
  create: [CommentCreateWithoutAuthorInput!]
  createMany: CommentCreateManyAuthorInputEnvelope
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAuthorInput!]
}

input CommentUpdateManyWithoutCommentInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutCommentInput!]
  create: [CommentCreateWithoutCommentInput!]
  createMany: CommentCreateManyCommentInputEnvelope
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutCommentInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutCommentInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutCommentInput!]
}

input CommentUpdateManyWithoutLaptopInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutLaptopInput!]
  create: [CommentCreateWithoutLaptopInput!]
  createMany: CommentCreateManyLaptopInputEnvelope
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutLaptopInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutLaptopInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutLaptopInput!]
}

input CommentUpdateOneWithoutCommentsInput {
  connect: CommentWhereUniqueInput
  connectOrCreate: CommentCreateOrConnectWithoutCommentsInput
  create: CommentCreateWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  update: CommentUpdateWithoutCommentsInput
  upsert: CommentUpsertWithoutCommentsInput
}

input CommentUpdateWithWhereUniqueWithoutAuthorInput {
  data: CommentUpdateWithoutAuthorInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutCommentInput {
  data: CommentUpdateWithoutCommentInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithWhereUniqueWithoutLaptopInput {
  data: CommentUpdateWithoutLaptopInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithoutAuthorInput {
  comment: CommentUpdateOneWithoutCommentsInput
  comments: CommentUpdateManyWithoutCommentInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  isStaff: BoolFieldUpdateOperationsInput
  laptop: LaptopUpdateOneRequiredWithoutCommentsInput
  rank: EnumRankFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateWithoutCommentInput {
  author: PersonUpdateOneRequiredWithoutCommentsInput
  comments: CommentUpdateManyWithoutCommentInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  isStaff: BoolFieldUpdateOperationsInput
  laptop: LaptopUpdateOneRequiredWithoutCommentsInput
  rank: EnumRankFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateWithoutCommentsInput {
  author: PersonUpdateOneRequiredWithoutCommentsInput
  comment: CommentUpdateOneWithoutCommentsInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  isStaff: BoolFieldUpdateOperationsInput
  laptop: LaptopUpdateOneRequiredWithoutCommentsInput
  rank: EnumRankFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateWithoutLaptopInput {
  author: PersonUpdateOneRequiredWithoutCommentsInput
  comment: CommentUpdateOneWithoutCommentsInput
  comments: CommentUpdateManyWithoutCommentInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  isStaff: BoolFieldUpdateOperationsInput
  rank: EnumRankFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpsertWithWhereUniqueWithoutAuthorInput {
  create: CommentCreateWithoutAuthorInput!
  update: CommentUpdateWithoutAuthorInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutCommentInput {
  create: CommentCreateWithoutCommentInput!
  update: CommentUpdateWithoutCommentInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithWhereUniqueWithoutLaptopInput {
  create: CommentCreateWithoutLaptopInput!
  update: CommentUpdateWithoutLaptopInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithoutCommentsInput {
  create: CommentCreateWithoutCommentsInput!
  update: CommentUpdateWithoutCommentsInput!
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  author: PersonRelationFilter
  authorId: StringFilter
  comment: CommentRelationFilter
  commentId: IntNullableFilter
  comments: CommentListRelationFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  isStaff: BoolFilter
  laptop: LaptopRelationFilter
  laptopId: IntFilter
  rank: EnumRankFilter
  updatedAt: DateTimeFilter
}

input CommentWhereUniqueInput {
  id: Int
}

type Customer {
  _count: CustomerCount
  createdAt: Timestamp!
  created_at: Timestamp!
  id: String!
  profile: Person!
  purchases(cursor: PurchaseWhereUniqueInput, distinct: [PurchaseScalarFieldEnum!], orderBy: [PurchaseOrderByWithRelationInput!], skip: Int, take: Int, where: PurchaseWhereInput): [Purchase!]!
  updatedAt: Timestamp!
  updated_at: Timestamp!
}

type CustomerCount {
  purchases: Int!
}

type CustomerCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  updatedAt: Int!
}

input CustomerCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input CustomerCreateInput {
  createdAt: Timestamp
  profile: PersonCreateNestedOneWithoutCustomerInput!
  purchases: PurchaseCreateNestedManyWithoutCustomerInput
  updatedAt: Timestamp
}

input CustomerCreateManyInput {
  createdAt: Timestamp
  id: String!
  updatedAt: Timestamp
}

input CustomerCreateNestedOneWithoutProfileInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutProfileInput
  create: CustomerCreateWithoutProfileInput
}

input CustomerCreateNestedOneWithoutPurchasesInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutPurchasesInput
  create: CustomerCreateWithoutPurchasesInput
}

input CustomerCreateOrConnectWithoutProfileInput {
  create: CustomerCreateWithoutProfileInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateOrConnectWithoutPurchasesInput {
  create: CustomerCreateWithoutPurchasesInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateWithoutProfileInput {
  createdAt: Timestamp
  purchases: PurchaseCreateNestedManyWithoutCustomerInput
  updatedAt: Timestamp
}

input CustomerCreateWithoutPurchasesInput {
  createdAt: Timestamp
  profile: PersonCreateNestedOneWithoutCustomerInput!
  updatedAt: Timestamp
}

type CustomerGroupBy {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  createdAt: Timestamp!
  id: String!
  updatedAt: Timestamp!
}

type CustomerMaxAggregate {
  createdAt: Timestamp
  id: String
  updatedAt: Timestamp
}

input CustomerMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

type CustomerMinAggregate {
  createdAt: Timestamp
  id: String
  updatedAt: Timestamp
}

input CustomerMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input CustomerOrderByWithAggregationInput {
  _count: CustomerCountOrderByAggregateInput
  _max: CustomerMaxOrderByAggregateInput
  _min: CustomerMinOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input CustomerOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  profile: PersonOrderByWithRelationInput
  purchases: PurchaseOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input CustomerRelationFilter {
  is: CustomerWhereInput
  isNot: CustomerWhereInput
}

enum CustomerScalarFieldEnum {
  createdAt
  id
  updatedAt
}

input CustomerScalarWhereWithAggregatesInput {
  AND: [CustomerScalarWhereWithAggregatesInput!]
  NOT: [CustomerScalarWhereWithAggregatesInput!]
  OR: [CustomerScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input CustomerUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  profile: PersonUpdateOneRequiredWithoutCustomerInput
  purchases: PurchaseUpdateManyWithoutCustomerInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CustomerUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CustomerUpdateOneRequiredWithoutPurchasesInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutPurchasesInput
  create: CustomerCreateWithoutPurchasesInput
  update: CustomerUpdateWithoutPurchasesInput
  upsert: CustomerUpsertWithoutPurchasesInput
}

input CustomerUpdateOneWithoutProfileInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutProfileInput
  create: CustomerCreateWithoutProfileInput
  delete: Boolean
  disconnect: Boolean
  update: CustomerUpdateWithoutProfileInput
  upsert: CustomerUpsertWithoutProfileInput
}

input CustomerUpdateWithoutProfileInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  purchases: PurchaseUpdateManyWithoutCustomerInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CustomerUpdateWithoutPurchasesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  profile: PersonUpdateOneRequiredWithoutCustomerInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CustomerUpsertWithoutProfileInput {
  create: CustomerCreateWithoutProfileInput!
  update: CustomerUpdateWithoutProfileInput!
}

input CustomerUpsertWithoutPurchasesInput {
  create: CustomerCreateWithoutPurchasesInput!
  update: CustomerUpdateWithoutPurchasesInput!
}

input CustomerWhereInput {
  AND: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  profile: PersonRelationFilter
  purchases: PurchaseListRelationFilter
  updatedAt: DateTimeFilter
}

input CustomerWhereUniqueInput {
  id: String
}

input DateTimeFieldUpdateOperationsInput {
  set: Timestamp
}

input DateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeWithAggregatesFilter
  notIn: [Timestamp!]
}

type Discount {
  _count: DiscountCount
  createdAt: Timestamp!
  created_at: Timestamp!
  id: Int!
  laptops(cursor: LaptopWhereUniqueInput, distinct: [LaptopScalarFieldEnum!], orderBy: [LaptopOrderByWithRelationInput!], skip: Int, take: Int, where: LaptopWhereInput): [Laptop!]!
  updatedAt: Timestamp!
  updated_at: Timestamp!
  value: Float!
}

type DiscountAvgAggregate {
  id: Float
  value: Float
}

input DiscountAvgOrderByAggregateInput {
  id: SortOrder
  value: SortOrder
}

type DiscountCount {
  laptops: Int!
}

type DiscountCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  updatedAt: Int!
  value: Int!
}

input DiscountCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  value: SortOrder
}

input DiscountCreateInput {
  createdAt: Timestamp
  laptops: LaptopCreateNestedManyWithoutDiscountInput
  updatedAt: Timestamp
  value: Float
}

input DiscountCreateManyInput {
  createdAt: Timestamp
  id: Int
  updatedAt: Timestamp
  value: Float
}

input DiscountCreateNestedOneWithoutLaptopsInput {
  connect: DiscountWhereUniqueInput
  connectOrCreate: DiscountCreateOrConnectWithoutLaptopsInput
  create: DiscountCreateWithoutLaptopsInput
}

input DiscountCreateOrConnectWithoutLaptopsInput {
  create: DiscountCreateWithoutLaptopsInput!
  where: DiscountWhereUniqueInput!
}

input DiscountCreateWithoutLaptopsInput {
  createdAt: Timestamp
  updatedAt: Timestamp
  value: Float
}

type DiscountGroupBy {
  _avg: DiscountAvgAggregate
  _count: DiscountCountAggregate
  _max: DiscountMaxAggregate
  _min: DiscountMinAggregate
  _sum: DiscountSumAggregate
  createdAt: Timestamp!
  id: Int!
  updatedAt: Timestamp!
  value: Float!
}

type DiscountMaxAggregate {
  createdAt: Timestamp
  id: Int
  updatedAt: Timestamp
  value: Float
}

input DiscountMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  value: SortOrder
}

type DiscountMinAggregate {
  createdAt: Timestamp
  id: Int
  updatedAt: Timestamp
  value: Float
}

input DiscountMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  value: SortOrder
}

input DiscountOrderByWithAggregationInput {
  _avg: DiscountAvgOrderByAggregateInput
  _count: DiscountCountOrderByAggregateInput
  _max: DiscountMaxOrderByAggregateInput
  _min: DiscountMinOrderByAggregateInput
  _sum: DiscountSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  value: SortOrder
}

input DiscountOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  laptops: LaptopOrderByRelationAggregateInput
  updatedAt: SortOrder
  value: SortOrder
}

input DiscountRelationFilter {
  is: DiscountWhereInput
  isNot: DiscountWhereInput
}

enum DiscountScalarFieldEnum {
  createdAt
  id
  updatedAt
  value
}

input DiscountScalarWhereWithAggregatesInput {
  AND: [DiscountScalarWhereWithAggregatesInput!]
  NOT: [DiscountScalarWhereWithAggregatesInput!]
  OR: [DiscountScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  value: FloatWithAggregatesFilter
}

type DiscountSumAggregate {
  id: Int
  value: Float
}

input DiscountSumOrderByAggregateInput {
  id: SortOrder
  value: SortOrder
}

input DiscountUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  laptops: LaptopUpdateManyWithoutDiscountInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  value: FloatFieldUpdateOperationsInput
}

input DiscountUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  value: FloatFieldUpdateOperationsInput
}

input DiscountUpdateOneWithoutLaptopsInput {
  connect: DiscountWhereUniqueInput
  connectOrCreate: DiscountCreateOrConnectWithoutLaptopsInput
  create: DiscountCreateWithoutLaptopsInput
  delete: Boolean
  disconnect: Boolean
  update: DiscountUpdateWithoutLaptopsInput
  upsert: DiscountUpsertWithoutLaptopsInput
}

input DiscountUpdateWithoutLaptopsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  value: FloatFieldUpdateOperationsInput
}

input DiscountUpsertWithoutLaptopsInput {
  create: DiscountCreateWithoutLaptopsInput!
  update: DiscountUpdateWithoutLaptopsInput!
}

input DiscountWhereInput {
  AND: [DiscountWhereInput!]
  NOT: [DiscountWhereInput!]
  OR: [DiscountWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  laptops: LaptopListRelationFilter
  updatedAt: DateTimeFilter
  value: FloatFilter
}

input DiscountWhereUniqueInput {
  id: Int
  value: Float
}

input EnumGenderFieldUpdateOperationsInput {
  set: Gender
}

input EnumGenderFilter {
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderFilter
  notIn: [Gender!]
}

input EnumGenderWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumGenderFilter
  _min: NestedEnumGenderFilter
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderWithAggregatesFilter
  notIn: [Gender!]
}

input EnumOSFieldUpdateOperationsInput {
  set: OS
}

input EnumOSFilter {
  equals: OS
  in: [OS!]
  not: NestedEnumOSFilter
  notIn: [OS!]
}

input EnumOSWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumOSFilter
  _min: NestedEnumOSFilter
  equals: OS
  in: [OS!]
  not: NestedEnumOSWithAggregatesFilter
  notIn: [OS!]
}

input EnumRankFieldUpdateOperationsInput {
  set: Rank
}

input EnumRankFilter {
  equals: Rank
  in: [Rank!]
  not: NestedEnumRankFilter
  notIn: [Rank!]
}

input EnumRankWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRankFilter
  _min: NestedEnumRankFilter
  equals: Rank
  in: [Rank!]
  not: NestedEnumRankWithAggregatesFilter
  notIn: [Rank!]
}

input EnumRoleFieldUpdateOperationsInput {
  set: Role
}

input EnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input EnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

enum Gender {
  FEMALE
  MALE
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Laptop {
  _count: LaptopCount
  adapter: String!
  brand: String!
  comments(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  cpu: String!
  createdAt: Timestamp!
  created_at: Timestamp!
  dimensionsAndWeight: String!
  dimensions_and_weight: String!
  discount: Discount
  discountId: Int
  discount_id: Float!
  display: String!
  fans: String!
  graphicCard: String!
  graphic_card: String!
  id: Int!
  keyboard: String!
  material: String!
  model: String!
  os: OS!
  ports: String!
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  priceMap: PriceMap
  priceMapId: Int
  price_map: Float!
  purchases(cursor: PurchaseWhereUniqueInput, distinct: [PurchaseScalarFieldEnum!], orderBy: [PurchaseOrderByWithRelationInput!], skip: Int, take: Int, where: PurchaseWhereInput): [Purchase!]!
  ram: String!
  releaseDate: Timestamp!
  release_date: Timestamp!
  security: String!
  speakers: String!
  specialFeatures: String!
  special_features: String!
  storage: String!
  updatedAt: Timestamp!
  updated_at: Timestamp!
  webcam: String!
  wifi: String!
}

type LaptopAvgAggregate {
  discountId: Float
  id: Float
  priceMapId: Float
}

input LaptopAvgOrderByAggregateInput {
  discountId: SortOrder
  id: SortOrder
  priceMapId: SortOrder
}

type LaptopCount {
  comments: Int!
  posts: Int!
  purchases: Int!
}

type LaptopCountAggregate {
  _all: Int!
  adapter: Int!
  brand: Int!
  cpu: Int!
  createdAt: Int!
  dimensionsAndWeight: Int!
  discountId: Int!
  display: Int!
  fans: Int!
  graphicCard: Int!
  id: Int!
  keyboard: Int!
  material: Int!
  model: Int!
  os: Int!
  ports: Int!
  priceMapId: Int!
  ram: Int!
  releaseDate: Int!
  security: Int!
  speakers: Int!
  specialFeatures: Int!
  storage: Int!
  updatedAt: Int!
  webcam: Int!
  wifi: Int!
}

input LaptopCountOrderByAggregateInput {
  adapter: SortOrder
  brand: SortOrder
  cpu: SortOrder
  createdAt: SortOrder
  dimensionsAndWeight: SortOrder
  discountId: SortOrder
  display: SortOrder
  fans: SortOrder
  graphicCard: SortOrder
  id: SortOrder
  keyboard: SortOrder
  material: SortOrder
  model: SortOrder
  os: SortOrder
  ports: SortOrder
  priceMapId: SortOrder
  ram: SortOrder
  releaseDate: SortOrder
  security: SortOrder
  speakers: SortOrder
  specialFeatures: SortOrder
  storage: SortOrder
  updatedAt: SortOrder
  webcam: SortOrder
  wifi: SortOrder
}

input LaptopCreateInput {
  adapter: String
  brand: String
  comments: CommentCreateNestedManyWithoutLaptopInput
  cpu: String
  createdAt: Timestamp
  dimensionsAndWeight: String
  discount: DiscountCreateNestedOneWithoutLaptopsInput
  display: String
  fans: String
  graphicCard: String
  keyboard: String
  material: String
  model: String
  os: OS
  ports: String
  posts: PostCreateNestedManyWithoutLaptopsInput
  priceMap: PriceMapCreateNestedOneWithoutLaptopsInput
  purchases: PurchaseCreateNestedManyWithoutLaptopsInput
  ram: String
  releaseDate: Timestamp
  security: String
  speakers: String
  specialFeatures: String
  storage: String
  updatedAt: Timestamp
  webcam: String
  wifi: String
}

input LaptopCreateManyDiscountInput {
  adapter: String
  brand: String
  cpu: String
  createdAt: Timestamp
  dimensionsAndWeight: String
  display: String
  fans: String
  graphicCard: String
  id: Int
  keyboard: String
  material: String
  model: String
  os: OS
  ports: String
  priceMapId: Int
  ram: String
  releaseDate: Timestamp
  security: String
  speakers: String
  specialFeatures: String
  storage: String
  updatedAt: Timestamp
  webcam: String
  wifi: String
}

input LaptopCreateManyDiscountInputEnvelope {
  data: [LaptopCreateManyDiscountInput!]!
  skipDuplicates: Boolean
}

input LaptopCreateManyInput {
  adapter: String
  brand: String
  cpu: String
  createdAt: Timestamp
  dimensionsAndWeight: String
  discountId: Int
  display: String
  fans: String
  graphicCard: String
  id: Int
  keyboard: String
  material: String
  model: String
  os: OS
  ports: String
  priceMapId: Int
  ram: String
  releaseDate: Timestamp
  security: String
  speakers: String
  specialFeatures: String
  storage: String
  updatedAt: Timestamp
  webcam: String
  wifi: String
}

input LaptopCreateManyPriceMapInput {
  adapter: String
  brand: String
  cpu: String
  createdAt: Timestamp
  dimensionsAndWeight: String
  discountId: Int
  display: String
  fans: String
  graphicCard: String
  id: Int
  keyboard: String
  material: String
  model: String
  os: OS
  ports: String
  ram: String
  releaseDate: Timestamp
  security: String
  speakers: String
  specialFeatures: String
  storage: String
  updatedAt: Timestamp
  webcam: String
  wifi: String
}

input LaptopCreateManyPriceMapInputEnvelope {
  data: [LaptopCreateManyPriceMapInput!]!
  skipDuplicates: Boolean
}

input LaptopCreateNestedManyWithoutDiscountInput {
  connect: [LaptopWhereUniqueInput!]
  connectOrCreate: [LaptopCreateOrConnectWithoutDiscountInput!]
  create: [LaptopCreateWithoutDiscountInput!]
  createMany: LaptopCreateManyDiscountInputEnvelope
}

input LaptopCreateNestedManyWithoutPostsInput {
  connect: [LaptopWhereUniqueInput!]
  connectOrCreate: [LaptopCreateOrConnectWithoutPostsInput!]
  create: [LaptopCreateWithoutPostsInput!]
}

input LaptopCreateNestedManyWithoutPriceMapInput {
  connect: [LaptopWhereUniqueInput!]
  connectOrCreate: [LaptopCreateOrConnectWithoutPriceMapInput!]
  create: [LaptopCreateWithoutPriceMapInput!]
  createMany: LaptopCreateManyPriceMapInputEnvelope
}

input LaptopCreateNestedManyWithoutPurchasesInput {
  connect: [LaptopWhereUniqueInput!]
  connectOrCreate: [LaptopCreateOrConnectWithoutPurchasesInput!]
  create: [LaptopCreateWithoutPurchasesInput!]
}

input LaptopCreateNestedOneWithoutCommentsInput {
  connect: LaptopWhereUniqueInput
  connectOrCreate: LaptopCreateOrConnectWithoutCommentsInput
  create: LaptopCreateWithoutCommentsInput
}

input LaptopCreateOrConnectWithoutCommentsInput {
  create: LaptopCreateWithoutCommentsInput!
  where: LaptopWhereUniqueInput!
}

input LaptopCreateOrConnectWithoutDiscountInput {
  create: LaptopCreateWithoutDiscountInput!
  where: LaptopWhereUniqueInput!
}

input LaptopCreateOrConnectWithoutPostsInput {
  create: LaptopCreateWithoutPostsInput!
  where: LaptopWhereUniqueInput!
}

input LaptopCreateOrConnectWithoutPriceMapInput {
  create: LaptopCreateWithoutPriceMapInput!
  where: LaptopWhereUniqueInput!
}

input LaptopCreateOrConnectWithoutPurchasesInput {
  create: LaptopCreateWithoutPurchasesInput!
  where: LaptopWhereUniqueInput!
}

input LaptopCreateWithoutCommentsInput {
  adapter: String
  brand: String
  cpu: String
  createdAt: Timestamp
  dimensionsAndWeight: String
  discount: DiscountCreateNestedOneWithoutLaptopsInput
  display: String
  fans: String
  graphicCard: String
  keyboard: String
  material: String
  model: String
  os: OS
  ports: String
  posts: PostCreateNestedManyWithoutLaptopsInput
  priceMap: PriceMapCreateNestedOneWithoutLaptopsInput
  purchases: PurchaseCreateNestedManyWithoutLaptopsInput
  ram: String
  releaseDate: Timestamp
  security: String
  speakers: String
  specialFeatures: String
  storage: String
  updatedAt: Timestamp
  webcam: String
  wifi: String
}

input LaptopCreateWithoutDiscountInput {
  adapter: String
  brand: String
  comments: CommentCreateNestedManyWithoutLaptopInput
  cpu: String
  createdAt: Timestamp
  dimensionsAndWeight: String
  display: String
  fans: String
  graphicCard: String
  keyboard: String
  material: String
  model: String
  os: OS
  ports: String
  posts: PostCreateNestedManyWithoutLaptopsInput
  priceMap: PriceMapCreateNestedOneWithoutLaptopsInput
  purchases: PurchaseCreateNestedManyWithoutLaptopsInput
  ram: String
  releaseDate: Timestamp
  security: String
  speakers: String
  specialFeatures: String
  storage: String
  updatedAt: Timestamp
  webcam: String
  wifi: String
}

input LaptopCreateWithoutPostsInput {
  adapter: String
  brand: String
  comments: CommentCreateNestedManyWithoutLaptopInput
  cpu: String
  createdAt: Timestamp
  dimensionsAndWeight: String
  discount: DiscountCreateNestedOneWithoutLaptopsInput
  display: String
  fans: String
  graphicCard: String
  keyboard: String
  material: String
  model: String
  os: OS
  ports: String
  priceMap: PriceMapCreateNestedOneWithoutLaptopsInput
  purchases: PurchaseCreateNestedManyWithoutLaptopsInput
  ram: String
  releaseDate: Timestamp
  security: String
  speakers: String
  specialFeatures: String
  storage: String
  updatedAt: Timestamp
  webcam: String
  wifi: String
}

input LaptopCreateWithoutPriceMapInput {
  adapter: String
  brand: String
  comments: CommentCreateNestedManyWithoutLaptopInput
  cpu: String
  createdAt: Timestamp
  dimensionsAndWeight: String
  discount: DiscountCreateNestedOneWithoutLaptopsInput
  display: String
  fans: String
  graphicCard: String
  keyboard: String
  material: String
  model: String
  os: OS
  ports: String
  posts: PostCreateNestedManyWithoutLaptopsInput
  purchases: PurchaseCreateNestedManyWithoutLaptopsInput
  ram: String
  releaseDate: Timestamp
  security: String
  speakers: String
  specialFeatures: String
  storage: String
  updatedAt: Timestamp
  webcam: String
  wifi: String
}

input LaptopCreateWithoutPurchasesInput {
  adapter: String
  brand: String
  comments: CommentCreateNestedManyWithoutLaptopInput
  cpu: String
  createdAt: Timestamp
  dimensionsAndWeight: String
  discount: DiscountCreateNestedOneWithoutLaptopsInput
  display: String
  fans: String
  graphicCard: String
  keyboard: String
  material: String
  model: String
  os: OS
  ports: String
  posts: PostCreateNestedManyWithoutLaptopsInput
  priceMap: PriceMapCreateNestedOneWithoutLaptopsInput
  ram: String
  releaseDate: Timestamp
  security: String
  speakers: String
  specialFeatures: String
  storage: String
  updatedAt: Timestamp
  webcam: String
  wifi: String
}

type LaptopGroupBy {
  _avg: LaptopAvgAggregate
  _count: LaptopCountAggregate
  _max: LaptopMaxAggregate
  _min: LaptopMinAggregate
  _sum: LaptopSumAggregate
  adapter: String!
  brand: String!
  cpu: String!
  createdAt: Timestamp!
  dimensionsAndWeight: String!
  discountId: Int
  display: String!
  fans: String!
  graphicCard: String!
  id: Int!
  keyboard: String!
  material: String!
  model: String!
  os: OS!
  ports: String!
  priceMapId: Int
  ram: String!
  releaseDate: Timestamp!
  security: String!
  speakers: String!
  specialFeatures: String!
  storage: String!
  updatedAt: Timestamp!
  webcam: String!
  wifi: String!
}

input LaptopListRelationFilter {
  every: LaptopWhereInput
  none: LaptopWhereInput
  some: LaptopWhereInput
}

type LaptopMaxAggregate {
  adapter: String
  brand: String
  cpu: String
  createdAt: Timestamp
  dimensionsAndWeight: String
  discountId: Int
  display: String
  fans: String
  graphicCard: String
  id: Int
  keyboard: String
  material: String
  model: String
  os: OS
  ports: String
  priceMapId: Int
  ram: String
  releaseDate: Timestamp
  security: String
  speakers: String
  specialFeatures: String
  storage: String
  updatedAt: Timestamp
  webcam: String
  wifi: String
}

input LaptopMaxOrderByAggregateInput {
  adapter: SortOrder
  brand: SortOrder
  cpu: SortOrder
  createdAt: SortOrder
  dimensionsAndWeight: SortOrder
  discountId: SortOrder
  display: SortOrder
  fans: SortOrder
  graphicCard: SortOrder
  id: SortOrder
  keyboard: SortOrder
  material: SortOrder
  model: SortOrder
  os: SortOrder
  ports: SortOrder
  priceMapId: SortOrder
  ram: SortOrder
  releaseDate: SortOrder
  security: SortOrder
  speakers: SortOrder
  specialFeatures: SortOrder
  storage: SortOrder
  updatedAt: SortOrder
  webcam: SortOrder
  wifi: SortOrder
}

type LaptopMinAggregate {
  adapter: String
  brand: String
  cpu: String
  createdAt: Timestamp
  dimensionsAndWeight: String
  discountId: Int
  display: String
  fans: String
  graphicCard: String
  id: Int
  keyboard: String
  material: String
  model: String
  os: OS
  ports: String
  priceMapId: Int
  ram: String
  releaseDate: Timestamp
  security: String
  speakers: String
  specialFeatures: String
  storage: String
  updatedAt: Timestamp
  webcam: String
  wifi: String
}

input LaptopMinOrderByAggregateInput {
  adapter: SortOrder
  brand: SortOrder
  cpu: SortOrder
  createdAt: SortOrder
  dimensionsAndWeight: SortOrder
  discountId: SortOrder
  display: SortOrder
  fans: SortOrder
  graphicCard: SortOrder
  id: SortOrder
  keyboard: SortOrder
  material: SortOrder
  model: SortOrder
  os: SortOrder
  ports: SortOrder
  priceMapId: SortOrder
  ram: SortOrder
  releaseDate: SortOrder
  security: SortOrder
  speakers: SortOrder
  specialFeatures: SortOrder
  storage: SortOrder
  updatedAt: SortOrder
  webcam: SortOrder
  wifi: SortOrder
}

input LaptopOrderByRelationAggregateInput {
  _count: SortOrder
}

input LaptopOrderByWithAggregationInput {
  _avg: LaptopAvgOrderByAggregateInput
  _count: LaptopCountOrderByAggregateInput
  _max: LaptopMaxOrderByAggregateInput
  _min: LaptopMinOrderByAggregateInput
  _sum: LaptopSumOrderByAggregateInput
  adapter: SortOrder
  brand: SortOrder
  cpu: SortOrder
  createdAt: SortOrder
  dimensionsAndWeight: SortOrder
  discountId: SortOrder
  display: SortOrder
  fans: SortOrder
  graphicCard: SortOrder
  id: SortOrder
  keyboard: SortOrder
  material: SortOrder
  model: SortOrder
  os: SortOrder
  ports: SortOrder
  priceMapId: SortOrder
  ram: SortOrder
  releaseDate: SortOrder
  security: SortOrder
  speakers: SortOrder
  specialFeatures: SortOrder
  storage: SortOrder
  updatedAt: SortOrder
  webcam: SortOrder
  wifi: SortOrder
}

input LaptopOrderByWithRelationInput {
  adapter: SortOrder
  brand: SortOrder
  comments: CommentOrderByRelationAggregateInput
  cpu: SortOrder
  createdAt: SortOrder
  dimensionsAndWeight: SortOrder
  discount: DiscountOrderByWithRelationInput
  discountId: SortOrder
  display: SortOrder
  fans: SortOrder
  graphicCard: SortOrder
  id: SortOrder
  keyboard: SortOrder
  material: SortOrder
  model: SortOrder
  os: SortOrder
  ports: SortOrder
  posts: PostOrderByRelationAggregateInput
  priceMap: PriceMapOrderByWithRelationInput
  priceMapId: SortOrder
  purchases: PurchaseOrderByRelationAggregateInput
  ram: SortOrder
  releaseDate: SortOrder
  security: SortOrder
  speakers: SortOrder
  specialFeatures: SortOrder
  storage: SortOrder
  updatedAt: SortOrder
  webcam: SortOrder
  wifi: SortOrder
}

input LaptopRelationFilter {
  is: LaptopWhereInput
  isNot: LaptopWhereInput
}

enum LaptopScalarFieldEnum {
  adapter
  brand
  cpu
  createdAt
  dimensionsAndWeight
  discountId
  display
  fans
  graphicCard
  id
  keyboard
  material
  model
  os
  ports
  priceMapId
  ram
  releaseDate
  security
  speakers
  specialFeatures
  storage
  updatedAt
  webcam
  wifi
}

input LaptopScalarWhereInput {
  AND: [LaptopScalarWhereInput!]
  NOT: [LaptopScalarWhereInput!]
  OR: [LaptopScalarWhereInput!]
  adapter: StringFilter
  brand: StringFilter
  cpu: StringFilter
  createdAt: DateTimeFilter
  dimensionsAndWeight: StringFilter
  discountId: IntNullableFilter
  display: StringFilter
  fans: StringFilter
  graphicCard: StringFilter
  id: IntFilter
  keyboard: StringFilter
  material: StringFilter
  model: StringFilter
  os: EnumOSFilter
  ports: StringFilter
  priceMapId: IntNullableFilter
  ram: StringFilter
  releaseDate: DateTimeFilter
  security: StringFilter
  speakers: StringFilter
  specialFeatures: StringFilter
  storage: StringFilter
  updatedAt: DateTimeFilter
  webcam: StringFilter
  wifi: StringFilter
}

input LaptopScalarWhereWithAggregatesInput {
  AND: [LaptopScalarWhereWithAggregatesInput!]
  NOT: [LaptopScalarWhereWithAggregatesInput!]
  OR: [LaptopScalarWhereWithAggregatesInput!]
  adapter: StringWithAggregatesFilter
  brand: StringWithAggregatesFilter
  cpu: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  dimensionsAndWeight: StringWithAggregatesFilter
  discountId: IntNullableWithAggregatesFilter
  display: StringWithAggregatesFilter
  fans: StringWithAggregatesFilter
  graphicCard: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  keyboard: StringWithAggregatesFilter
  material: StringWithAggregatesFilter
  model: StringWithAggregatesFilter
  os: EnumOSWithAggregatesFilter
  ports: StringWithAggregatesFilter
  priceMapId: IntNullableWithAggregatesFilter
  ram: StringWithAggregatesFilter
  releaseDate: DateTimeWithAggregatesFilter
  security: StringWithAggregatesFilter
  speakers: StringWithAggregatesFilter
  specialFeatures: StringWithAggregatesFilter
  storage: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  webcam: StringWithAggregatesFilter
  wifi: StringWithAggregatesFilter
}

type LaptopSumAggregate {
  discountId: Int
  id: Int
  priceMapId: Int
}

input LaptopSumOrderByAggregateInput {
  discountId: SortOrder
  id: SortOrder
  priceMapId: SortOrder
}

input LaptopUpdateInput {
  adapter: StringFieldUpdateOperationsInput
  brand: StringFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutLaptopInput
  cpu: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  dimensionsAndWeight: StringFieldUpdateOperationsInput
  discount: DiscountUpdateOneWithoutLaptopsInput
  display: StringFieldUpdateOperationsInput
  fans: StringFieldUpdateOperationsInput
  graphicCard: StringFieldUpdateOperationsInput
  keyboard: StringFieldUpdateOperationsInput
  material: StringFieldUpdateOperationsInput
  model: StringFieldUpdateOperationsInput
  os: EnumOSFieldUpdateOperationsInput
  ports: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutLaptopsInput
  priceMap: PriceMapUpdateOneWithoutLaptopsInput
  purchases: PurchaseUpdateManyWithoutLaptopsInput
  ram: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  security: StringFieldUpdateOperationsInput
  speakers: StringFieldUpdateOperationsInput
  specialFeatures: StringFieldUpdateOperationsInput
  storage: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  webcam: StringFieldUpdateOperationsInput
  wifi: StringFieldUpdateOperationsInput
}

input LaptopUpdateManyMutationInput {
  adapter: StringFieldUpdateOperationsInput
  brand: StringFieldUpdateOperationsInput
  cpu: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  dimensionsAndWeight: StringFieldUpdateOperationsInput
  display: StringFieldUpdateOperationsInput
  fans: StringFieldUpdateOperationsInput
  graphicCard: StringFieldUpdateOperationsInput
  keyboard: StringFieldUpdateOperationsInput
  material: StringFieldUpdateOperationsInput
  model: StringFieldUpdateOperationsInput
  os: EnumOSFieldUpdateOperationsInput
  ports: StringFieldUpdateOperationsInput
  ram: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  security: StringFieldUpdateOperationsInput
  speakers: StringFieldUpdateOperationsInput
  specialFeatures: StringFieldUpdateOperationsInput
  storage: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  webcam: StringFieldUpdateOperationsInput
  wifi: StringFieldUpdateOperationsInput
}

input LaptopUpdateManyWithWhereWithoutDiscountInput {
  data: LaptopUpdateManyMutationInput!
  where: LaptopScalarWhereInput!
}

input LaptopUpdateManyWithWhereWithoutPostsInput {
  data: LaptopUpdateManyMutationInput!
  where: LaptopScalarWhereInput!
}

input LaptopUpdateManyWithWhereWithoutPriceMapInput {
  data: LaptopUpdateManyMutationInput!
  where: LaptopScalarWhereInput!
}

input LaptopUpdateManyWithWhereWithoutPurchasesInput {
  data: LaptopUpdateManyMutationInput!
  where: LaptopScalarWhereInput!
}

input LaptopUpdateManyWithoutDiscountInput {
  connect: [LaptopWhereUniqueInput!]
  connectOrCreate: [LaptopCreateOrConnectWithoutDiscountInput!]
  create: [LaptopCreateWithoutDiscountInput!]
  createMany: LaptopCreateManyDiscountInputEnvelope
  delete: [LaptopWhereUniqueInput!]
  deleteMany: [LaptopScalarWhereInput!]
  disconnect: [LaptopWhereUniqueInput!]
  set: [LaptopWhereUniqueInput!]
  update: [LaptopUpdateWithWhereUniqueWithoutDiscountInput!]
  updateMany: [LaptopUpdateManyWithWhereWithoutDiscountInput!]
  upsert: [LaptopUpsertWithWhereUniqueWithoutDiscountInput!]
}

input LaptopUpdateManyWithoutPostsInput {
  connect: [LaptopWhereUniqueInput!]
  connectOrCreate: [LaptopCreateOrConnectWithoutPostsInput!]
  create: [LaptopCreateWithoutPostsInput!]
  delete: [LaptopWhereUniqueInput!]
  deleteMany: [LaptopScalarWhereInput!]
  disconnect: [LaptopWhereUniqueInput!]
  set: [LaptopWhereUniqueInput!]
  update: [LaptopUpdateWithWhereUniqueWithoutPostsInput!]
  updateMany: [LaptopUpdateManyWithWhereWithoutPostsInput!]
  upsert: [LaptopUpsertWithWhereUniqueWithoutPostsInput!]
}

input LaptopUpdateManyWithoutPriceMapInput {
  connect: [LaptopWhereUniqueInput!]
  connectOrCreate: [LaptopCreateOrConnectWithoutPriceMapInput!]
  create: [LaptopCreateWithoutPriceMapInput!]
  createMany: LaptopCreateManyPriceMapInputEnvelope
  delete: [LaptopWhereUniqueInput!]
  deleteMany: [LaptopScalarWhereInput!]
  disconnect: [LaptopWhereUniqueInput!]
  set: [LaptopWhereUniqueInput!]
  update: [LaptopUpdateWithWhereUniqueWithoutPriceMapInput!]
  updateMany: [LaptopUpdateManyWithWhereWithoutPriceMapInput!]
  upsert: [LaptopUpsertWithWhereUniqueWithoutPriceMapInput!]
}

input LaptopUpdateManyWithoutPurchasesInput {
  connect: [LaptopWhereUniqueInput!]
  connectOrCreate: [LaptopCreateOrConnectWithoutPurchasesInput!]
  create: [LaptopCreateWithoutPurchasesInput!]
  delete: [LaptopWhereUniqueInput!]
  deleteMany: [LaptopScalarWhereInput!]
  disconnect: [LaptopWhereUniqueInput!]
  set: [LaptopWhereUniqueInput!]
  update: [LaptopUpdateWithWhereUniqueWithoutPurchasesInput!]
  updateMany: [LaptopUpdateManyWithWhereWithoutPurchasesInput!]
  upsert: [LaptopUpsertWithWhereUniqueWithoutPurchasesInput!]
}

input LaptopUpdateOneRequiredWithoutCommentsInput {
  connect: LaptopWhereUniqueInput
  connectOrCreate: LaptopCreateOrConnectWithoutCommentsInput
  create: LaptopCreateWithoutCommentsInput
  update: LaptopUpdateWithoutCommentsInput
  upsert: LaptopUpsertWithoutCommentsInput
}

input LaptopUpdateWithWhereUniqueWithoutDiscountInput {
  data: LaptopUpdateWithoutDiscountInput!
  where: LaptopWhereUniqueInput!
}

input LaptopUpdateWithWhereUniqueWithoutPostsInput {
  data: LaptopUpdateWithoutPostsInput!
  where: LaptopWhereUniqueInput!
}

input LaptopUpdateWithWhereUniqueWithoutPriceMapInput {
  data: LaptopUpdateWithoutPriceMapInput!
  where: LaptopWhereUniqueInput!
}

input LaptopUpdateWithWhereUniqueWithoutPurchasesInput {
  data: LaptopUpdateWithoutPurchasesInput!
  where: LaptopWhereUniqueInput!
}

input LaptopUpdateWithoutCommentsInput {
  adapter: StringFieldUpdateOperationsInput
  brand: StringFieldUpdateOperationsInput
  cpu: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  dimensionsAndWeight: StringFieldUpdateOperationsInput
  discount: DiscountUpdateOneWithoutLaptopsInput
  display: StringFieldUpdateOperationsInput
  fans: StringFieldUpdateOperationsInput
  graphicCard: StringFieldUpdateOperationsInput
  keyboard: StringFieldUpdateOperationsInput
  material: StringFieldUpdateOperationsInput
  model: StringFieldUpdateOperationsInput
  os: EnumOSFieldUpdateOperationsInput
  ports: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutLaptopsInput
  priceMap: PriceMapUpdateOneWithoutLaptopsInput
  purchases: PurchaseUpdateManyWithoutLaptopsInput
  ram: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  security: StringFieldUpdateOperationsInput
  speakers: StringFieldUpdateOperationsInput
  specialFeatures: StringFieldUpdateOperationsInput
  storage: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  webcam: StringFieldUpdateOperationsInput
  wifi: StringFieldUpdateOperationsInput
}

input LaptopUpdateWithoutDiscountInput {
  adapter: StringFieldUpdateOperationsInput
  brand: StringFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutLaptopInput
  cpu: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  dimensionsAndWeight: StringFieldUpdateOperationsInput
  display: StringFieldUpdateOperationsInput
  fans: StringFieldUpdateOperationsInput
  graphicCard: StringFieldUpdateOperationsInput
  keyboard: StringFieldUpdateOperationsInput
  material: StringFieldUpdateOperationsInput
  model: StringFieldUpdateOperationsInput
  os: EnumOSFieldUpdateOperationsInput
  ports: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutLaptopsInput
  priceMap: PriceMapUpdateOneWithoutLaptopsInput
  purchases: PurchaseUpdateManyWithoutLaptopsInput
  ram: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  security: StringFieldUpdateOperationsInput
  speakers: StringFieldUpdateOperationsInput
  specialFeatures: StringFieldUpdateOperationsInput
  storage: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  webcam: StringFieldUpdateOperationsInput
  wifi: StringFieldUpdateOperationsInput
}

input LaptopUpdateWithoutPostsInput {
  adapter: StringFieldUpdateOperationsInput
  brand: StringFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutLaptopInput
  cpu: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  dimensionsAndWeight: StringFieldUpdateOperationsInput
  discount: DiscountUpdateOneWithoutLaptopsInput
  display: StringFieldUpdateOperationsInput
  fans: StringFieldUpdateOperationsInput
  graphicCard: StringFieldUpdateOperationsInput
  keyboard: StringFieldUpdateOperationsInput
  material: StringFieldUpdateOperationsInput
  model: StringFieldUpdateOperationsInput
  os: EnumOSFieldUpdateOperationsInput
  ports: StringFieldUpdateOperationsInput
  priceMap: PriceMapUpdateOneWithoutLaptopsInput
  purchases: PurchaseUpdateManyWithoutLaptopsInput
  ram: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  security: StringFieldUpdateOperationsInput
  speakers: StringFieldUpdateOperationsInput
  specialFeatures: StringFieldUpdateOperationsInput
  storage: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  webcam: StringFieldUpdateOperationsInput
  wifi: StringFieldUpdateOperationsInput
}

input LaptopUpdateWithoutPriceMapInput {
  adapter: StringFieldUpdateOperationsInput
  brand: StringFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutLaptopInput
  cpu: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  dimensionsAndWeight: StringFieldUpdateOperationsInput
  discount: DiscountUpdateOneWithoutLaptopsInput
  display: StringFieldUpdateOperationsInput
  fans: StringFieldUpdateOperationsInput
  graphicCard: StringFieldUpdateOperationsInput
  keyboard: StringFieldUpdateOperationsInput
  material: StringFieldUpdateOperationsInput
  model: StringFieldUpdateOperationsInput
  os: EnumOSFieldUpdateOperationsInput
  ports: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutLaptopsInput
  purchases: PurchaseUpdateManyWithoutLaptopsInput
  ram: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  security: StringFieldUpdateOperationsInput
  speakers: StringFieldUpdateOperationsInput
  specialFeatures: StringFieldUpdateOperationsInput
  storage: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  webcam: StringFieldUpdateOperationsInput
  wifi: StringFieldUpdateOperationsInput
}

input LaptopUpdateWithoutPurchasesInput {
  adapter: StringFieldUpdateOperationsInput
  brand: StringFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutLaptopInput
  cpu: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  dimensionsAndWeight: StringFieldUpdateOperationsInput
  discount: DiscountUpdateOneWithoutLaptopsInput
  display: StringFieldUpdateOperationsInput
  fans: StringFieldUpdateOperationsInput
  graphicCard: StringFieldUpdateOperationsInput
  keyboard: StringFieldUpdateOperationsInput
  material: StringFieldUpdateOperationsInput
  model: StringFieldUpdateOperationsInput
  os: EnumOSFieldUpdateOperationsInput
  ports: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutLaptopsInput
  priceMap: PriceMapUpdateOneWithoutLaptopsInput
  ram: StringFieldUpdateOperationsInput
  releaseDate: DateTimeFieldUpdateOperationsInput
  security: StringFieldUpdateOperationsInput
  speakers: StringFieldUpdateOperationsInput
  specialFeatures: StringFieldUpdateOperationsInput
  storage: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  webcam: StringFieldUpdateOperationsInput
  wifi: StringFieldUpdateOperationsInput
}

input LaptopUpsertWithWhereUniqueWithoutDiscountInput {
  create: LaptopCreateWithoutDiscountInput!
  update: LaptopUpdateWithoutDiscountInput!
  where: LaptopWhereUniqueInput!
}

input LaptopUpsertWithWhereUniqueWithoutPostsInput {
  create: LaptopCreateWithoutPostsInput!
  update: LaptopUpdateWithoutPostsInput!
  where: LaptopWhereUniqueInput!
}

input LaptopUpsertWithWhereUniqueWithoutPriceMapInput {
  create: LaptopCreateWithoutPriceMapInput!
  update: LaptopUpdateWithoutPriceMapInput!
  where: LaptopWhereUniqueInput!
}

input LaptopUpsertWithWhereUniqueWithoutPurchasesInput {
  create: LaptopCreateWithoutPurchasesInput!
  update: LaptopUpdateWithoutPurchasesInput!
  where: LaptopWhereUniqueInput!
}

input LaptopUpsertWithoutCommentsInput {
  create: LaptopCreateWithoutCommentsInput!
  update: LaptopUpdateWithoutCommentsInput!
}

input LaptopWhereInput {
  AND: [LaptopWhereInput!]
  NOT: [LaptopWhereInput!]
  OR: [LaptopWhereInput!]
  adapter: StringFilter
  brand: StringFilter
  comments: CommentListRelationFilter
  cpu: StringFilter
  createdAt: DateTimeFilter
  dimensionsAndWeight: StringFilter
  discount: DiscountRelationFilter
  discountId: IntNullableFilter
  display: StringFilter
  fans: StringFilter
  graphicCard: StringFilter
  id: IntFilter
  keyboard: StringFilter
  material: StringFilter
  model: StringFilter
  os: EnumOSFilter
  ports: StringFilter
  posts: PostListRelationFilter
  priceMap: PriceMapRelationFilter
  priceMapId: IntNullableFilter
  purchases: PurchaseListRelationFilter
  ram: StringFilter
  releaseDate: DateTimeFilter
  security: StringFilter
  speakers: StringFilter
  specialFeatures: StringFilter
  storage: StringFilter
  updatedAt: DateTimeFilter
  webcam: StringFilter
  wifi: StringFilter
}

input LaptopWhereUniqueInput {
  id: Int
}

type Mutation {
  createComment(data: CommentCreateInput!): Comment!
  createCustomer(data: CustomerCreateInput!): Customer!
  createDiscount(data: DiscountCreateInput!): Discount!
  createLaptop(data: LaptopCreateInput!): Laptop!
  createManyComment(data: [CommentCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCustomer(data: [CustomerCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyDiscount(data: [DiscountCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyLaptop(data: [LaptopCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPassage(data: [PassageCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPerson(data: [PersonCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPost(data: [PostCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPriceMap(data: [PriceMapCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPurchase(data: [PurchaseCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createPassage(data: PassageCreateInput!): Passage!
  createPerson(data: PersonCreateInput!): Person!
  createPost(data: PostCreateInput!): Post!
  createPriceMap(data: PriceMapCreateInput!): PriceMap!
  createPurchase(data: PurchaseCreateInput!): Purchase!
  createUser(data: UserCreateInput!): User!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteDiscount(where: DiscountWhereUniqueInput!): Discount
  deleteLaptop(where: LaptopWhereUniqueInput!): Laptop
  deleteManyComment(where: CommentWhereInput): AffectedRowsOutput!
  deleteManyCustomer(where: CustomerWhereInput): AffectedRowsOutput!
  deleteManyDiscount(where: DiscountWhereInput): AffectedRowsOutput!
  deleteManyLaptop(where: LaptopWhereInput): AffectedRowsOutput!
  deleteManyPassage(where: PassageWhereInput): AffectedRowsOutput!
  deleteManyPerson(where: PersonWhereInput): AffectedRowsOutput!
  deleteManyPost(where: PostWhereInput): AffectedRowsOutput!
  deleteManyPriceMap(where: PriceMapWhereInput): AffectedRowsOutput!
  deleteManyPurchase(where: PurchaseWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deletePassage(where: PassageWhereUniqueInput!): Passage
  deletePerson(where: PersonWhereUniqueInput!): Person
  deletePost(where: PostWhereUniqueInput!): Post
  deletePriceMap(where: PriceMapWhereUniqueInput!): PriceMap
  deletePurchase(where: PurchaseWhereUniqueInput!): Purchase
  deleteUser(where: UserWhereUniqueInput!): User
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateDiscount(data: DiscountUpdateInput!, where: DiscountWhereUniqueInput!): Discount
  updateLaptop(data: LaptopUpdateInput!, where: LaptopWhereUniqueInput!): Laptop
  updateManyComment(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): AffectedRowsOutput!
  updateManyCustomer(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): AffectedRowsOutput!
  updateManyDiscount(data: DiscountUpdateManyMutationInput!, where: DiscountWhereInput): AffectedRowsOutput!
  updateManyLaptop(data: LaptopUpdateManyMutationInput!, where: LaptopWhereInput): AffectedRowsOutput!
  updateManyPassage(data: PassageUpdateManyMutationInput!, where: PassageWhereInput): AffectedRowsOutput!
  updateManyPerson(data: PersonUpdateManyMutationInput!, where: PersonWhereInput): AffectedRowsOutput!
  updateManyPost(data: PostUpdateManyMutationInput!, where: PostWhereInput): AffectedRowsOutput!
  updateManyPriceMap(data: PriceMapUpdateManyMutationInput!, where: PriceMapWhereInput): AffectedRowsOutput!
  updateManyPurchase(data: PurchaseUpdateManyMutationInput!, where: PurchaseWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updatePassage(data: PassageUpdateInput!, where: PassageWhereUniqueInput!): Passage
  updatePerson(data: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updatePriceMap(data: PriceMapUpdateInput!, where: PriceMapWhereUniqueInput!): PriceMap
  updatePurchase(data: PurchaseUpdateInput!, where: PurchaseWhereUniqueInput!): Purchase
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertComment(create: CommentCreateInput!, update: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment!
  upsertCustomer(create: CustomerCreateInput!, update: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer!
  upsertDiscount(create: DiscountCreateInput!, update: DiscountUpdateInput!, where: DiscountWhereUniqueInput!): Discount!
  upsertLaptop(create: LaptopCreateInput!, update: LaptopUpdateInput!, where: LaptopWhereUniqueInput!): Laptop!
  upsertPassage(create: PassageCreateInput!, update: PassageUpdateInput!, where: PassageWhereUniqueInput!): Passage!
  upsertPerson(create: PersonCreateInput!, update: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person!
  upsertPost(create: PostCreateInput!, update: PostUpdateInput!, where: PostWhereUniqueInput!): Post!
  upsertPriceMap(create: PriceMapCreateInput!, update: PriceMapUpdateInput!, where: PriceMapWhereUniqueInput!): PriceMap!
  upsertPurchase(create: PurchaseCreateInput!, update: PurchaseUpdateInput!, where: PurchaseWhereUniqueInput!): Purchase!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeFilter
  notIn: [Timestamp!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: Timestamp
  gt: Timestamp
  gte: Timestamp
  in: [Timestamp!]
  lt: Timestamp
  lte: Timestamp
  not: NestedDateTimeWithAggregatesFilter
  notIn: [Timestamp!]
}

input NestedEnumGenderFilter {
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderFilter
  notIn: [Gender!]
}

input NestedEnumGenderWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumGenderFilter
  _min: NestedEnumGenderFilter
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderWithAggregatesFilter
  notIn: [Gender!]
}

input NestedEnumOSFilter {
  equals: OS
  in: [OS!]
  not: NestedEnumOSFilter
  notIn: [OS!]
}

input NestedEnumOSWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumOSFilter
  _min: NestedEnumOSFilter
  equals: OS
  in: [OS!]
  not: NestedEnumOSWithAggregatesFilter
  notIn: [OS!]
}

input NestedEnumRankFilter {
  equals: Rank
  in: [Rank!]
  not: NestedEnumRankFilter
  notIn: [Rank!]
}

input NestedEnumRankWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRankFilter
  _min: NestedEnumRankFilter
  equals: Rank
  in: [Rank!]
  not: NestedEnumRankWithAggregatesFilter
  notIn: [Rank!]
}

input NestedEnumRoleFilter {
  equals: Role
  in: [Role!]
  not: NestedEnumRoleFilter
  notIn: [Role!]
}

input NestedEnumRoleWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumRoleFilter
  _min: NestedEnumRoleFilter
  equals: Role
  in: [Role!]
  not: NestedEnumRoleWithAggregatesFilter
  notIn: [Role!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

enum OS {
  ANDROID
  FREEDOS
  LINUX
  MACOS
  WINDOWS
}

type Passage {
  Post: Post!
  content: String!
  header: String!
  id: Int!
  postId: Int!
  post_id: Float!
}

type PassageAvgAggregate {
  id: Float
  postId: Float
}

input PassageAvgOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
}

type PassageCountAggregate {
  _all: Int!
  content: Int!
  header: Int!
  id: Int!
  postId: Int!
}

input PassageCountOrderByAggregateInput {
  content: SortOrder
  header: SortOrder
  id: SortOrder
  postId: SortOrder
}

input PassageCreateInput {
  Post: PostCreateNestedOneWithoutPassagesInput!
  content: String!
  header: String!
}

input PassageCreateManyInput {
  content: String!
  header: String!
  id: Int
  postId: Int!
}

input PassageCreateManyPostInput {
  content: String!
  header: String!
  id: Int
}

input PassageCreateManyPostInputEnvelope {
  data: [PassageCreateManyPostInput!]!
  skipDuplicates: Boolean
}

input PassageCreateNestedManyWithoutPostInput {
  connect: [PassageWhereUniqueInput!]
  connectOrCreate: [PassageCreateOrConnectWithoutPostInput!]
  create: [PassageCreateWithoutPostInput!]
  createMany: PassageCreateManyPostInputEnvelope
}

input PassageCreateOrConnectWithoutPostInput {
  create: PassageCreateWithoutPostInput!
  where: PassageWhereUniqueInput!
}

input PassageCreateWithoutPostInput {
  content: String!
  header: String!
}

type PassageGroupBy {
  _avg: PassageAvgAggregate
  _count: PassageCountAggregate
  _max: PassageMaxAggregate
  _min: PassageMinAggregate
  _sum: PassageSumAggregate
  content: String!
  header: String!
  id: Int!
  postId: Int!
}

input PassageListRelationFilter {
  every: PassageWhereInput
  none: PassageWhereInput
  some: PassageWhereInput
}

type PassageMaxAggregate {
  content: String
  header: String
  id: Int
  postId: Int
}

input PassageMaxOrderByAggregateInput {
  content: SortOrder
  header: SortOrder
  id: SortOrder
  postId: SortOrder
}

type PassageMinAggregate {
  content: String
  header: String
  id: Int
  postId: Int
}

input PassageMinOrderByAggregateInput {
  content: SortOrder
  header: SortOrder
  id: SortOrder
  postId: SortOrder
}

input PassageOrderByRelationAggregateInput {
  _count: SortOrder
}

input PassageOrderByWithAggregationInput {
  _avg: PassageAvgOrderByAggregateInput
  _count: PassageCountOrderByAggregateInput
  _max: PassageMaxOrderByAggregateInput
  _min: PassageMinOrderByAggregateInput
  _sum: PassageSumOrderByAggregateInput
  content: SortOrder
  header: SortOrder
  id: SortOrder
  postId: SortOrder
}

input PassageOrderByWithRelationInput {
  Post: PostOrderByWithRelationInput
  content: SortOrder
  header: SortOrder
  id: SortOrder
  postId: SortOrder
}

enum PassageScalarFieldEnum {
  content
  header
  id
  postId
}

input PassageScalarWhereInput {
  AND: [PassageScalarWhereInput!]
  NOT: [PassageScalarWhereInput!]
  OR: [PassageScalarWhereInput!]
  content: StringFilter
  header: StringFilter
  id: IntFilter
  postId: IntFilter
}

input PassageScalarWhereWithAggregatesInput {
  AND: [PassageScalarWhereWithAggregatesInput!]
  NOT: [PassageScalarWhereWithAggregatesInput!]
  OR: [PassageScalarWhereWithAggregatesInput!]
  content: StringWithAggregatesFilter
  header: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  postId: IntWithAggregatesFilter
}

type PassageSumAggregate {
  id: Int
  postId: Int
}

input PassageSumOrderByAggregateInput {
  id: SortOrder
  postId: SortOrder
}

input PassageUpdateInput {
  Post: PostUpdateOneRequiredWithoutPassagesInput
  content: StringFieldUpdateOperationsInput
  header: StringFieldUpdateOperationsInput
}

input PassageUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  header: StringFieldUpdateOperationsInput
}

input PassageUpdateManyWithWhereWithoutPostInput {
  data: PassageUpdateManyMutationInput!
  where: PassageScalarWhereInput!
}

input PassageUpdateManyWithoutPostInput {
  connect: [PassageWhereUniqueInput!]
  connectOrCreate: [PassageCreateOrConnectWithoutPostInput!]
  create: [PassageCreateWithoutPostInput!]
  createMany: PassageCreateManyPostInputEnvelope
  delete: [PassageWhereUniqueInput!]
  deleteMany: [PassageScalarWhereInput!]
  disconnect: [PassageWhereUniqueInput!]
  set: [PassageWhereUniqueInput!]
  update: [PassageUpdateWithWhereUniqueWithoutPostInput!]
  updateMany: [PassageUpdateManyWithWhereWithoutPostInput!]
  upsert: [PassageUpsertWithWhereUniqueWithoutPostInput!]
}

input PassageUpdateWithWhereUniqueWithoutPostInput {
  data: PassageUpdateWithoutPostInput!
  where: PassageWhereUniqueInput!
}

input PassageUpdateWithoutPostInput {
  content: StringFieldUpdateOperationsInput
  header: StringFieldUpdateOperationsInput
}

input PassageUpsertWithWhereUniqueWithoutPostInput {
  create: PassageCreateWithoutPostInput!
  update: PassageUpdateWithoutPostInput!
  where: PassageWhereUniqueInput!
}

input PassageWhereInput {
  AND: [PassageWhereInput!]
  NOT: [PassageWhereInput!]
  OR: [PassageWhereInput!]
  Post: PostRelationFilter
  content: StringFilter
  header: StringFilter
  id: IntFilter
  postId: IntFilter
}

input PassageWhereUniqueInput {
  id: Int
}

type Person {
  _count: PersonCount
  address: String!
  comments(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  createdAt: Timestamp!
  created_at: Timestamp!
  customer: Customer
  email: String
  fullname: String!
  gender: Gender!
  id: String!
  phone: String!
  updatedAt: Timestamp!
  updated_at: Timestamp!
  user: User
}

type PersonCount {
  comments: Int!
}

type PersonCountAggregate {
  _all: Int!
  address: Int!
  createdAt: Int!
  email: Int!
  fullname: Int!
  gender: Int!
  id: Int!
  phone: Int!
  updatedAt: Int!
}

input PersonCountOrderByAggregateInput {
  address: SortOrder
  createdAt: SortOrder
  email: SortOrder
  fullname: SortOrder
  gender: SortOrder
  id: SortOrder
  phone: SortOrder
  updatedAt: SortOrder
}

input PersonCreateInput {
  address: String
  comments: CommentCreateNestedManyWithoutAuthorInput
  createdAt: Timestamp
  customer: CustomerCreateNestedOneWithoutProfileInput
  email: String
  fullname: String!
  gender: Gender
  id: String
  phone: String!
  updatedAt: Timestamp
  user: UserCreateNestedOneWithoutProfileInput
}

input PersonCreateManyInput {
  address: String
  createdAt: Timestamp
  email: String
  fullname: String!
  gender: Gender
  id: String
  phone: String!
  updatedAt: Timestamp
}

input PersonCreateNestedOneWithoutCommentsInput {
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutCommentsInput
  create: PersonCreateWithoutCommentsInput
}

input PersonCreateNestedOneWithoutCustomerInput {
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutCustomerInput
  create: PersonCreateWithoutCustomerInput
}

input PersonCreateNestedOneWithoutUserInput {
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutUserInput
  create: PersonCreateWithoutUserInput
}

input PersonCreateOrConnectWithoutCommentsInput {
  create: PersonCreateWithoutCommentsInput!
  where: PersonWhereUniqueInput!
}

input PersonCreateOrConnectWithoutCustomerInput {
  create: PersonCreateWithoutCustomerInput!
  where: PersonWhereUniqueInput!
}

input PersonCreateOrConnectWithoutUserInput {
  create: PersonCreateWithoutUserInput!
  where: PersonWhereUniqueInput!
}

input PersonCreateWithoutCommentsInput {
  address: String
  createdAt: Timestamp
  customer: CustomerCreateNestedOneWithoutProfileInput
  email: String
  fullname: String!
  gender: Gender
  id: String
  phone: String!
  updatedAt: Timestamp
  user: UserCreateNestedOneWithoutProfileInput
}

input PersonCreateWithoutCustomerInput {
  address: String
  comments: CommentCreateNestedManyWithoutAuthorInput
  createdAt: Timestamp
  email: String
  fullname: String!
  gender: Gender
  id: String
  phone: String!
  updatedAt: Timestamp
  user: UserCreateNestedOneWithoutProfileInput
}

input PersonCreateWithoutUserInput {
  address: String
  comments: CommentCreateNestedManyWithoutAuthorInput
  createdAt: Timestamp
  customer: CustomerCreateNestedOneWithoutProfileInput
  email: String
  fullname: String!
  gender: Gender
  id: String
  phone: String!
  updatedAt: Timestamp
}

type PersonGroupBy {
  _count: PersonCountAggregate
  _max: PersonMaxAggregate
  _min: PersonMinAggregate
  address: String!
  createdAt: Timestamp!
  email: String
  fullname: String!
  gender: Gender!
  id: String!
  phone: String!
  updatedAt: Timestamp!
}

type PersonMaxAggregate {
  address: String
  createdAt: Timestamp
  email: String
  fullname: String
  gender: Gender
  id: String
  phone: String
  updatedAt: Timestamp
}

input PersonMaxOrderByAggregateInput {
  address: SortOrder
  createdAt: SortOrder
  email: SortOrder
  fullname: SortOrder
  gender: SortOrder
  id: SortOrder
  phone: SortOrder
  updatedAt: SortOrder
}

type PersonMinAggregate {
  address: String
  createdAt: Timestamp
  email: String
  fullname: String
  gender: Gender
  id: String
  phone: String
  updatedAt: Timestamp
}

input PersonMinOrderByAggregateInput {
  address: SortOrder
  createdAt: SortOrder
  email: SortOrder
  fullname: SortOrder
  gender: SortOrder
  id: SortOrder
  phone: SortOrder
  updatedAt: SortOrder
}

input PersonOrderByWithAggregationInput {
  _count: PersonCountOrderByAggregateInput
  _max: PersonMaxOrderByAggregateInput
  _min: PersonMinOrderByAggregateInput
  address: SortOrder
  createdAt: SortOrder
  email: SortOrder
  fullname: SortOrder
  gender: SortOrder
  id: SortOrder
  phone: SortOrder
  updatedAt: SortOrder
}

input PersonOrderByWithRelationInput {
  address: SortOrder
  comments: CommentOrderByRelationAggregateInput
  createdAt: SortOrder
  customer: CustomerOrderByWithRelationInput
  email: SortOrder
  fullname: SortOrder
  gender: SortOrder
  id: SortOrder
  phone: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
}

input PersonRelationFilter {
  is: PersonWhereInput
  isNot: PersonWhereInput
}

enum PersonScalarFieldEnum {
  address
  createdAt
  email
  fullname
  gender
  id
  phone
  updatedAt
}

input PersonScalarWhereWithAggregatesInput {
  AND: [PersonScalarWhereWithAggregatesInput!]
  NOT: [PersonScalarWhereWithAggregatesInput!]
  OR: [PersonScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  email: StringNullableWithAggregatesFilter
  fullname: StringWithAggregatesFilter
  gender: EnumGenderWithAggregatesFilter
  id: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input PersonUpdateInput {
  address: StringFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutAuthorInput
  createdAt: DateTimeFieldUpdateOperationsInput
  customer: CustomerUpdateOneWithoutProfileInput
  email: NullableStringFieldUpdateOperationsInput
  fullname: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutProfileInput
}

input PersonUpdateManyMutationInput {
  address: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  fullname: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PersonUpdateOneRequiredWithoutCommentsInput {
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutCommentsInput
  create: PersonCreateWithoutCommentsInput
  update: PersonUpdateWithoutCommentsInput
  upsert: PersonUpsertWithoutCommentsInput
}

input PersonUpdateOneRequiredWithoutCustomerInput {
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutCustomerInput
  create: PersonCreateWithoutCustomerInput
  update: PersonUpdateWithoutCustomerInput
  upsert: PersonUpsertWithoutCustomerInput
}

input PersonUpdateOneRequiredWithoutUserInput {
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutUserInput
  create: PersonCreateWithoutUserInput
  update: PersonUpdateWithoutUserInput
  upsert: PersonUpsertWithoutUserInput
}

input PersonUpdateWithoutCommentsInput {
  address: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  customer: CustomerUpdateOneWithoutProfileInput
  email: NullableStringFieldUpdateOperationsInput
  fullname: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutProfileInput
}

input PersonUpdateWithoutCustomerInput {
  address: StringFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutAuthorInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: NullableStringFieldUpdateOperationsInput
  fullname: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutProfileInput
}

input PersonUpdateWithoutUserInput {
  address: StringFieldUpdateOperationsInput
  comments: CommentUpdateManyWithoutAuthorInput
  createdAt: DateTimeFieldUpdateOperationsInput
  customer: CustomerUpdateOneWithoutProfileInput
  email: NullableStringFieldUpdateOperationsInput
  fullname: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  phone: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PersonUpsertWithoutCommentsInput {
  create: PersonCreateWithoutCommentsInput!
  update: PersonUpdateWithoutCommentsInput!
}

input PersonUpsertWithoutCustomerInput {
  create: PersonCreateWithoutCustomerInput!
  update: PersonUpdateWithoutCustomerInput!
}

input PersonUpsertWithoutUserInput {
  create: PersonCreateWithoutUserInput!
  update: PersonUpdateWithoutUserInput!
}

input PersonWhereInput {
  AND: [PersonWhereInput!]
  NOT: [PersonWhereInput!]
  OR: [PersonWhereInput!]
  address: StringFilter
  comments: CommentListRelationFilter
  createdAt: DateTimeFilter
  customer: CustomerRelationFilter
  email: StringNullableFilter
  fullname: StringFilter
  gender: EnumGenderFilter
  id: StringFilter
  phone: StringFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
}

input PersonWhereUniqueInput {
  email: String
  id: String
  phone: String
}

type Post {
  _count: PostCount
  author: User!
  createdAt: Timestamp!
  created_at: Timestamp!
  id: Int!
  laptops(cursor: LaptopWhereUniqueInput, distinct: [LaptopScalarFieldEnum!], orderBy: [LaptopOrderByWithRelationInput!], skip: Int, take: Int, where: LaptopWhereInput): [Laptop!]!
  passages(cursor: PassageWhereUniqueInput, distinct: [PassageScalarFieldEnum!], orderBy: [PassageOrderByWithRelationInput!], skip: Int, take: Int, where: PassageWhereInput): [Passage!]!
  title: String!
  updatedAt: Timestamp!
  updated_at: Timestamp!
  userId: String!
  user_id: String!
}

type PostAvgAggregate {
  id: Float
}

input PostAvgOrderByAggregateInput {
  id: SortOrder
}

type PostCount {
  laptops: Int!
  passages: Int!
}

type PostCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  title: Int!
  updatedAt: Int!
  userId: Int!
}

input PostCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostCreateInput {
  author: UserCreateNestedOneWithoutPostsInput!
  createdAt: Timestamp
  laptops: LaptopCreateNestedManyWithoutPostsInput
  passages: PassageCreateNestedManyWithoutPostInput
  title: String!
  updatedAt: Timestamp
}

input PostCreateManyAuthorInput {
  createdAt: Timestamp
  id: Int
  title: String!
  updatedAt: Timestamp
}

input PostCreateManyAuthorInputEnvelope {
  data: [PostCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input PostCreateManyInput {
  createdAt: Timestamp
  id: Int
  title: String!
  updatedAt: Timestamp
  userId: String!
}

input PostCreateNestedManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
}

input PostCreateNestedManyWithoutLaptopsInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutLaptopsInput!]
  create: [PostCreateWithoutLaptopsInput!]
}

input PostCreateNestedOneWithoutPassagesInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutPassagesInput
  create: PostCreateWithoutPassagesInput
}

input PostCreateOrConnectWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutLaptopsInput {
  create: PostCreateWithoutLaptopsInput!
  where: PostWhereUniqueInput!
}

input PostCreateOrConnectWithoutPassagesInput {
  create: PostCreateWithoutPassagesInput!
  where: PostWhereUniqueInput!
}

input PostCreateWithoutAuthorInput {
  createdAt: Timestamp
  laptops: LaptopCreateNestedManyWithoutPostsInput
  passages: PassageCreateNestedManyWithoutPostInput
  title: String!
  updatedAt: Timestamp
}

input PostCreateWithoutLaptopsInput {
  author: UserCreateNestedOneWithoutPostsInput!
  createdAt: Timestamp
  passages: PassageCreateNestedManyWithoutPostInput
  title: String!
  updatedAt: Timestamp
}

input PostCreateWithoutPassagesInput {
  author: UserCreateNestedOneWithoutPostsInput!
  createdAt: Timestamp
  laptops: LaptopCreateNestedManyWithoutPostsInput
  title: String!
  updatedAt: Timestamp
}

type PostGroupBy {
  _avg: PostAvgAggregate
  _count: PostCountAggregate
  _max: PostMaxAggregate
  _min: PostMinAggregate
  _sum: PostSumAggregate
  createdAt: Timestamp!
  id: Int!
  title: String!
  updatedAt: Timestamp!
  userId: String!
}

input PostListRelationFilter {
  every: PostWhereInput
  none: PostWhereInput
  some: PostWhereInput
}

type PostMaxAggregate {
  createdAt: Timestamp
  id: Int
  title: String
  updatedAt: Timestamp
  userId: String
}

input PostMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type PostMinAggregate {
  createdAt: Timestamp
  id: Int
  title: String
  updatedAt: Timestamp
  userId: String
}

input PostMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostOrderByRelationAggregateInput {
  _count: SortOrder
}

input PostOrderByWithAggregationInput {
  _avg: PostAvgOrderByAggregateInput
  _count: PostCountOrderByAggregateInput
  _max: PostMaxOrderByAggregateInput
  _min: PostMinOrderByAggregateInput
  _sum: PostSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostOrderByWithRelationInput {
  author: UserOrderByWithRelationInput
  createdAt: SortOrder
  id: SortOrder
  laptops: LaptopOrderByRelationAggregateInput
  passages: PassageOrderByRelationAggregateInput
  title: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input PostRelationFilter {
  is: PostWhereInput
  isNot: PostWhereInput
}

enum PostScalarFieldEnum {
  createdAt
  id
  title
  updatedAt
  userId
}

input PostScalarWhereInput {
  AND: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input PostScalarWhereWithAggregatesInput {
  AND: [PostScalarWhereWithAggregatesInput!]
  NOT: [PostScalarWhereWithAggregatesInput!]
  OR: [PostScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

type PostSumAggregate {
  id: Int
}

input PostSumOrderByAggregateInput {
  id: SortOrder
}

input PostUpdateInput {
  author: UserUpdateOneRequiredWithoutPostsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  laptops: LaptopUpdateManyWithoutPostsInput
  passages: PassageUpdateManyWithoutPostInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateManyWithWhereWithoutAuthorInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithWhereWithoutLaptopsInput {
  data: PostUpdateManyMutationInput!
  where: PostScalarWhereInput!
}

input PostUpdateManyWithoutAuthorInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutAuthorInput!]
  create: [PostCreateWithoutAuthorInput!]
  createMany: PostCreateManyAuthorInputEnvelope
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [PostUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
}

input PostUpdateManyWithoutLaptopsInput {
  connect: [PostWhereUniqueInput!]
  connectOrCreate: [PostCreateOrConnectWithoutLaptopsInput!]
  create: [PostCreateWithoutLaptopsInput!]
  delete: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  disconnect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutLaptopsInput!]
  updateMany: [PostUpdateManyWithWhereWithoutLaptopsInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutLaptopsInput!]
}

input PostUpdateOneRequiredWithoutPassagesInput {
  connect: PostWhereUniqueInput
  connectOrCreate: PostCreateOrConnectWithoutPassagesInput
  create: PostCreateWithoutPassagesInput
  update: PostUpdateWithoutPassagesInput
  upsert: PostUpsertWithoutPassagesInput
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  data: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithWhereUniqueWithoutLaptopsInput {
  data: PostUpdateWithoutLaptopsInput!
  where: PostWhereUniqueInput!
}

input PostUpdateWithoutAuthorInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  laptops: LaptopUpdateManyWithoutPostsInput
  passages: PassageUpdateManyWithoutPostInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateWithoutLaptopsInput {
  author: UserUpdateOneRequiredWithoutPostsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  passages: PassageUpdateManyWithoutPostInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpdateWithoutPassagesInput {
  author: UserUpdateOneRequiredWithoutPostsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  laptops: LaptopUpdateManyWithoutPostsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  create: PostCreateWithoutAuthorInput!
  update: PostUpdateWithoutAuthorInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithWhereUniqueWithoutLaptopsInput {
  create: PostCreateWithoutLaptopsInput!
  update: PostUpdateWithoutLaptopsInput!
  where: PostWhereUniqueInput!
}

input PostUpsertWithoutPassagesInput {
  create: PostCreateWithoutPassagesInput!
  update: PostUpdateWithoutPassagesInput!
}

input PostWhereInput {
  AND: [PostWhereInput!]
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  author: UserRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  laptops: LaptopListRelationFilter
  passages: PassageListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input PostWhereUniqueInput {
  id: Int
}

type PriceMap {
  _count: PriceMapCount
  createdAt: Timestamp!
  created_at: Timestamp!
  id: Int!
  laptops(cursor: LaptopWhereUniqueInput, distinct: [LaptopScalarFieldEnum!], orderBy: [LaptopOrderByWithRelationInput!], skip: Int, take: Int, where: LaptopWhereInput): [Laptop!]!
  price: Float!
  updatedAt: Timestamp!
  updated_at: Timestamp!
}

type PriceMapAvgAggregate {
  id: Float
  price: Float
}

input PriceMapAvgOrderByAggregateInput {
  id: SortOrder
  price: SortOrder
}

type PriceMapCount {
  laptops: Int!
}

type PriceMapCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  price: Int!
  updatedAt: Int!
}

input PriceMapCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  price: SortOrder
  updatedAt: SortOrder
}

input PriceMapCreateInput {
  createdAt: Timestamp
  laptops: LaptopCreateNestedManyWithoutPriceMapInput
  price: Float
  updatedAt: Timestamp
}

input PriceMapCreateManyInput {
  createdAt: Timestamp
  id: Int
  price: Float
  updatedAt: Timestamp
}

input PriceMapCreateNestedOneWithoutLaptopsInput {
  connect: PriceMapWhereUniqueInput
  connectOrCreate: PriceMapCreateOrConnectWithoutLaptopsInput
  create: PriceMapCreateWithoutLaptopsInput
}

input PriceMapCreateOrConnectWithoutLaptopsInput {
  create: PriceMapCreateWithoutLaptopsInput!
  where: PriceMapWhereUniqueInput!
}

input PriceMapCreateWithoutLaptopsInput {
  createdAt: Timestamp
  price: Float
  updatedAt: Timestamp
}

type PriceMapGroupBy {
  _avg: PriceMapAvgAggregate
  _count: PriceMapCountAggregate
  _max: PriceMapMaxAggregate
  _min: PriceMapMinAggregate
  _sum: PriceMapSumAggregate
  createdAt: Timestamp!
  id: Int!
  price: Float!
  updatedAt: Timestamp!
}

type PriceMapMaxAggregate {
  createdAt: Timestamp
  id: Int
  price: Float
  updatedAt: Timestamp
}

input PriceMapMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  price: SortOrder
  updatedAt: SortOrder
}

type PriceMapMinAggregate {
  createdAt: Timestamp
  id: Int
  price: Float
  updatedAt: Timestamp
}

input PriceMapMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  price: SortOrder
  updatedAt: SortOrder
}

input PriceMapOrderByWithAggregationInput {
  _avg: PriceMapAvgOrderByAggregateInput
  _count: PriceMapCountOrderByAggregateInput
  _max: PriceMapMaxOrderByAggregateInput
  _min: PriceMapMinOrderByAggregateInput
  _sum: PriceMapSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  price: SortOrder
  updatedAt: SortOrder
}

input PriceMapOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  laptops: LaptopOrderByRelationAggregateInput
  price: SortOrder
  updatedAt: SortOrder
}

input PriceMapRelationFilter {
  is: PriceMapWhereInput
  isNot: PriceMapWhereInput
}

enum PriceMapScalarFieldEnum {
  createdAt
  id
  price
  updatedAt
}

input PriceMapScalarWhereWithAggregatesInput {
  AND: [PriceMapScalarWhereWithAggregatesInput!]
  NOT: [PriceMapScalarWhereWithAggregatesInput!]
  OR: [PriceMapScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  price: FloatWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type PriceMapSumAggregate {
  id: Int
  price: Float
}

input PriceMapSumOrderByAggregateInput {
  id: SortOrder
  price: SortOrder
}

input PriceMapUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  laptops: LaptopUpdateManyWithoutPriceMapInput
  price: FloatFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PriceMapUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PriceMapUpdateOneWithoutLaptopsInput {
  connect: PriceMapWhereUniqueInput
  connectOrCreate: PriceMapCreateOrConnectWithoutLaptopsInput
  create: PriceMapCreateWithoutLaptopsInput
  delete: Boolean
  disconnect: Boolean
  update: PriceMapUpdateWithoutLaptopsInput
  upsert: PriceMapUpsertWithoutLaptopsInput
}

input PriceMapUpdateWithoutLaptopsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PriceMapUpsertWithoutLaptopsInput {
  create: PriceMapCreateWithoutLaptopsInput!
  update: PriceMapUpdateWithoutLaptopsInput!
}

input PriceMapWhereInput {
  AND: [PriceMapWhereInput!]
  NOT: [PriceMapWhereInput!]
  OR: [PriceMapWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  laptops: LaptopListRelationFilter
  price: FloatFilter
  updatedAt: DateTimeFilter
}

input PriceMapWhereUniqueInput {
  id: Int
  price: Float
}

type Purchase {
  _count: PurchaseCount
  createdAt: Timestamp!
  created_at: Timestamp!
  customer: Customer!
  customerId: String!
  customer_id: String!
  id: Int!
  laptops(cursor: LaptopWhereUniqueInput, distinct: [LaptopScalarFieldEnum!], orderBy: [LaptopOrderByWithRelationInput!], skip: Int, take: Int, where: LaptopWhereInput): [Laptop!]!
  updatedAt: Timestamp!
  updated_at: Timestamp!
}

type PurchaseAvgAggregate {
  id: Float
}

input PurchaseAvgOrderByAggregateInput {
  id: SortOrder
}

type PurchaseCount {
  laptops: Int!
}

type PurchaseCountAggregate {
  _all: Int!
  createdAt: Int!
  customerId: Int!
  id: Int!
  updatedAt: Int!
}

input PurchaseCountOrderByAggregateInput {
  createdAt: SortOrder
  customerId: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input PurchaseCreateInput {
  createdAt: Timestamp
  customer: CustomerCreateNestedOneWithoutPurchasesInput!
  laptops: LaptopCreateNestedManyWithoutPurchasesInput
  updatedAt: Timestamp
}

input PurchaseCreateManyCustomerInput {
  createdAt: Timestamp
  id: Int
  updatedAt: Timestamp
}

input PurchaseCreateManyCustomerInputEnvelope {
  data: [PurchaseCreateManyCustomerInput!]!
  skipDuplicates: Boolean
}

input PurchaseCreateManyInput {
  createdAt: Timestamp
  customerId: String!
  id: Int
  updatedAt: Timestamp
}

input PurchaseCreateNestedManyWithoutCustomerInput {
  connect: [PurchaseWhereUniqueInput!]
  connectOrCreate: [PurchaseCreateOrConnectWithoutCustomerInput!]
  create: [PurchaseCreateWithoutCustomerInput!]
  createMany: PurchaseCreateManyCustomerInputEnvelope
}

input PurchaseCreateNestedManyWithoutLaptopsInput {
  connect: [PurchaseWhereUniqueInput!]
  connectOrCreate: [PurchaseCreateOrConnectWithoutLaptopsInput!]
  create: [PurchaseCreateWithoutLaptopsInput!]
}

input PurchaseCreateOrConnectWithoutCustomerInput {
  create: PurchaseCreateWithoutCustomerInput!
  where: PurchaseWhereUniqueInput!
}

input PurchaseCreateOrConnectWithoutLaptopsInput {
  create: PurchaseCreateWithoutLaptopsInput!
  where: PurchaseWhereUniqueInput!
}

input PurchaseCreateWithoutCustomerInput {
  createdAt: Timestamp
  laptops: LaptopCreateNestedManyWithoutPurchasesInput
  updatedAt: Timestamp
}

input PurchaseCreateWithoutLaptopsInput {
  createdAt: Timestamp
  customer: CustomerCreateNestedOneWithoutPurchasesInput!
  updatedAt: Timestamp
}

type PurchaseGroupBy {
  _avg: PurchaseAvgAggregate
  _count: PurchaseCountAggregate
  _max: PurchaseMaxAggregate
  _min: PurchaseMinAggregate
  _sum: PurchaseSumAggregate
  createdAt: Timestamp!
  customerId: String!
  id: Int!
  updatedAt: Timestamp!
}

input PurchaseListRelationFilter {
  every: PurchaseWhereInput
  none: PurchaseWhereInput
  some: PurchaseWhereInput
}

type PurchaseMaxAggregate {
  createdAt: Timestamp
  customerId: String
  id: Int
  updatedAt: Timestamp
}

input PurchaseMaxOrderByAggregateInput {
  createdAt: SortOrder
  customerId: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

type PurchaseMinAggregate {
  createdAt: Timestamp
  customerId: String
  id: Int
  updatedAt: Timestamp
}

input PurchaseMinOrderByAggregateInput {
  createdAt: SortOrder
  customerId: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input PurchaseOrderByRelationAggregateInput {
  _count: SortOrder
}

input PurchaseOrderByWithAggregationInput {
  _avg: PurchaseAvgOrderByAggregateInput
  _count: PurchaseCountOrderByAggregateInput
  _max: PurchaseMaxOrderByAggregateInput
  _min: PurchaseMinOrderByAggregateInput
  _sum: PurchaseSumOrderByAggregateInput
  createdAt: SortOrder
  customerId: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input PurchaseOrderByWithRelationInput {
  createdAt: SortOrder
  customer: CustomerOrderByWithRelationInput
  customerId: SortOrder
  id: SortOrder
  laptops: LaptopOrderByRelationAggregateInput
  updatedAt: SortOrder
}

enum PurchaseScalarFieldEnum {
  createdAt
  customerId
  id
  updatedAt
}

input PurchaseScalarWhereInput {
  AND: [PurchaseScalarWhereInput!]
  NOT: [PurchaseScalarWhereInput!]
  OR: [PurchaseScalarWhereInput!]
  createdAt: DateTimeFilter
  customerId: StringFilter
  id: IntFilter
  updatedAt: DateTimeFilter
}

input PurchaseScalarWhereWithAggregatesInput {
  AND: [PurchaseScalarWhereWithAggregatesInput!]
  NOT: [PurchaseScalarWhereWithAggregatesInput!]
  OR: [PurchaseScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  customerId: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type PurchaseSumAggregate {
  id: Int
}

input PurchaseSumOrderByAggregateInput {
  id: SortOrder
}

input PurchaseUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  customer: CustomerUpdateOneRequiredWithoutPurchasesInput
  laptops: LaptopUpdateManyWithoutPurchasesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PurchaseUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PurchaseUpdateManyWithWhereWithoutCustomerInput {
  data: PurchaseUpdateManyMutationInput!
  where: PurchaseScalarWhereInput!
}

input PurchaseUpdateManyWithWhereWithoutLaptopsInput {
  data: PurchaseUpdateManyMutationInput!
  where: PurchaseScalarWhereInput!
}

input PurchaseUpdateManyWithoutCustomerInput {
  connect: [PurchaseWhereUniqueInput!]
  connectOrCreate: [PurchaseCreateOrConnectWithoutCustomerInput!]
  create: [PurchaseCreateWithoutCustomerInput!]
  createMany: PurchaseCreateManyCustomerInputEnvelope
  delete: [PurchaseWhereUniqueInput!]
  deleteMany: [PurchaseScalarWhereInput!]
  disconnect: [PurchaseWhereUniqueInput!]
  set: [PurchaseWhereUniqueInput!]
  update: [PurchaseUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [PurchaseUpdateManyWithWhereWithoutCustomerInput!]
  upsert: [PurchaseUpsertWithWhereUniqueWithoutCustomerInput!]
}

input PurchaseUpdateManyWithoutLaptopsInput {
  connect: [PurchaseWhereUniqueInput!]
  connectOrCreate: [PurchaseCreateOrConnectWithoutLaptopsInput!]
  create: [PurchaseCreateWithoutLaptopsInput!]
  delete: [PurchaseWhereUniqueInput!]
  deleteMany: [PurchaseScalarWhereInput!]
  disconnect: [PurchaseWhereUniqueInput!]
  set: [PurchaseWhereUniqueInput!]
  update: [PurchaseUpdateWithWhereUniqueWithoutLaptopsInput!]
  updateMany: [PurchaseUpdateManyWithWhereWithoutLaptopsInput!]
  upsert: [PurchaseUpsertWithWhereUniqueWithoutLaptopsInput!]
}

input PurchaseUpdateWithWhereUniqueWithoutCustomerInput {
  data: PurchaseUpdateWithoutCustomerInput!
  where: PurchaseWhereUniqueInput!
}

input PurchaseUpdateWithWhereUniqueWithoutLaptopsInput {
  data: PurchaseUpdateWithoutLaptopsInput!
  where: PurchaseWhereUniqueInput!
}

input PurchaseUpdateWithoutCustomerInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  laptops: LaptopUpdateManyWithoutPurchasesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PurchaseUpdateWithoutLaptopsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  customer: CustomerUpdateOneRequiredWithoutPurchasesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PurchaseUpsertWithWhereUniqueWithoutCustomerInput {
  create: PurchaseCreateWithoutCustomerInput!
  update: PurchaseUpdateWithoutCustomerInput!
  where: PurchaseWhereUniqueInput!
}

input PurchaseUpsertWithWhereUniqueWithoutLaptopsInput {
  create: PurchaseCreateWithoutLaptopsInput!
  update: PurchaseUpdateWithoutLaptopsInput!
  where: PurchaseWhereUniqueInput!
}

input PurchaseWhereInput {
  AND: [PurchaseWhereInput!]
  NOT: [PurchaseWhereInput!]
  OR: [PurchaseWhereInput!]
  createdAt: DateTimeFilter
  customer: CustomerRelationFilter
  customerId: StringFilter
  id: IntFilter
  laptops: LaptopListRelationFilter
  updatedAt: DateTimeFilter
}

input PurchaseWhereUniqueInput {
  id: Int
}

type Query {
  aggregateComment(cursor: CommentWhereUniqueInput, orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): AggregateComment!
  aggregateCustomer(cursor: CustomerWhereUniqueInput, orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): AggregateCustomer!
  aggregateDiscount(cursor: DiscountWhereUniqueInput, orderBy: [DiscountOrderByWithRelationInput!], skip: Int, take: Int, where: DiscountWhereInput): AggregateDiscount!
  aggregateLaptop(cursor: LaptopWhereUniqueInput, orderBy: [LaptopOrderByWithRelationInput!], skip: Int, take: Int, where: LaptopWhereInput): AggregateLaptop!
  aggregatePassage(cursor: PassageWhereUniqueInput, orderBy: [PassageOrderByWithRelationInput!], skip: Int, take: Int, where: PassageWhereInput): AggregatePassage!
  aggregatePerson(cursor: PersonWhereUniqueInput, orderBy: [PersonOrderByWithRelationInput!], skip: Int, take: Int, where: PersonWhereInput): AggregatePerson!
  aggregatePost(cursor: PostWhereUniqueInput, orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): AggregatePost!
  aggregatePriceMap(cursor: PriceMapWhereUniqueInput, orderBy: [PriceMapOrderByWithRelationInput!], skip: Int, take: Int, where: PriceMapWhereInput): AggregatePriceMap!
  aggregatePurchase(cursor: PurchaseWhereUniqueInput, orderBy: [PurchaseOrderByWithRelationInput!], skip: Int, take: Int, where: PurchaseWhereInput): AggregatePurchase!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  discount(where: DiscountWhereUniqueInput!): Discount
  discounts(cursor: DiscountWhereUniqueInput, distinct: [DiscountScalarFieldEnum!], orderBy: [DiscountOrderByWithRelationInput!], skip: Int, take: Int, where: DiscountWhereInput): [Discount!]!
  findFirstComment(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByWithRelationInput!], skip: Int, take: Int, where: CommentWhereInput): Comment
  findFirstCustomer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstDiscount(cursor: DiscountWhereUniqueInput, distinct: [DiscountScalarFieldEnum!], orderBy: [DiscountOrderByWithRelationInput!], skip: Int, take: Int, where: DiscountWhereInput): Discount
  findFirstLaptop(cursor: LaptopWhereUniqueInput, distinct: [LaptopScalarFieldEnum!], orderBy: [LaptopOrderByWithRelationInput!], skip: Int, take: Int, where: LaptopWhereInput): Laptop
  findFirstPassage(cursor: PassageWhereUniqueInput, distinct: [PassageScalarFieldEnum!], orderBy: [PassageOrderByWithRelationInput!], skip: Int, take: Int, where: PassageWhereInput): Passage
  findFirstPerson(cursor: PersonWhereUniqueInput, distinct: [PersonScalarFieldEnum!], orderBy: [PersonOrderByWithRelationInput!], skip: Int, take: Int, where: PersonWhereInput): Person
  findFirstPost(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): Post
  findFirstPriceMap(cursor: PriceMapWhereUniqueInput, distinct: [PriceMapScalarFieldEnum!], orderBy: [PriceMapOrderByWithRelationInput!], skip: Int, take: Int, where: PriceMapWhereInput): PriceMap
  findFirstPurchase(cursor: PurchaseWhereUniqueInput, distinct: [PurchaseScalarFieldEnum!], orderBy: [PurchaseOrderByWithRelationInput!], skip: Int, take: Int, where: PurchaseWhereInput): Purchase
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  groupByComment(by: [CommentScalarFieldEnum!]!, having: CommentScalarWhereWithAggregatesInput, orderBy: [CommentOrderByWithAggregationInput!], skip: Int, take: Int, where: CommentWhereInput): [CommentGroupBy!]!
  groupByCustomer(by: [CustomerScalarFieldEnum!]!, having: CustomerScalarWhereWithAggregatesInput, orderBy: [CustomerOrderByWithAggregationInput!], skip: Int, take: Int, where: CustomerWhereInput): [CustomerGroupBy!]!
  groupByDiscount(by: [DiscountScalarFieldEnum!]!, having: DiscountScalarWhereWithAggregatesInput, orderBy: [DiscountOrderByWithAggregationInput!], skip: Int, take: Int, where: DiscountWhereInput): [DiscountGroupBy!]!
  groupByLaptop(by: [LaptopScalarFieldEnum!]!, having: LaptopScalarWhereWithAggregatesInput, orderBy: [LaptopOrderByWithAggregationInput!], skip: Int, take: Int, where: LaptopWhereInput): [LaptopGroupBy!]!
  groupByPassage(by: [PassageScalarFieldEnum!]!, having: PassageScalarWhereWithAggregatesInput, orderBy: [PassageOrderByWithAggregationInput!], skip: Int, take: Int, where: PassageWhereInput): [PassageGroupBy!]!
  groupByPerson(by: [PersonScalarFieldEnum!]!, having: PersonScalarWhereWithAggregatesInput, orderBy: [PersonOrderByWithAggregationInput!], skip: Int, take: Int, where: PersonWhereInput): [PersonGroupBy!]!
  groupByPost(by: [PostScalarFieldEnum!]!, having: PostScalarWhereWithAggregatesInput, orderBy: [PostOrderByWithAggregationInput!], skip: Int, take: Int, where: PostWhereInput): [PostGroupBy!]!
  groupByPriceMap(by: [PriceMapScalarFieldEnum!]!, having: PriceMapScalarWhereWithAggregatesInput, orderBy: [PriceMapOrderByWithAggregationInput!], skip: Int, take: Int, where: PriceMapWhereInput): [PriceMapGroupBy!]!
  groupByPurchase(by: [PurchaseScalarFieldEnum!]!, having: PurchaseScalarWhereWithAggregatesInput, orderBy: [PurchaseOrderByWithAggregationInput!], skip: Int, take: Int, where: PurchaseWhereInput): [PurchaseGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  laptop(where: LaptopWhereUniqueInput!): Laptop
  laptops(cursor: LaptopWhereUniqueInput, distinct: [LaptopScalarFieldEnum!], orderBy: [LaptopOrderByWithRelationInput!], skip: Int, take: Int, where: LaptopWhereInput): [Laptop!]!
  login(email: String!, password: String!): Response!
  passage(where: PassageWhereUniqueInput!): Passage
  passages(cursor: PassageWhereUniqueInput, distinct: [PassageScalarFieldEnum!], orderBy: [PassageOrderByWithRelationInput!], skip: Int, take: Int, where: PassageWhereInput): [Passage!]!
  people(cursor: PersonWhereUniqueInput, distinct: [PersonScalarFieldEnum!], orderBy: [PersonOrderByWithRelationInput!], skip: Int, take: Int, where: PersonWhereInput): [Person!]!
  person(where: PersonWhereUniqueInput!): Person
  post(where: PostWhereUniqueInput!): Post
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  priceMap(where: PriceMapWhereUniqueInput!): PriceMap
  priceMaps(cursor: PriceMapWhereUniqueInput, distinct: [PriceMapScalarFieldEnum!], orderBy: [PriceMapOrderByWithRelationInput!], skip: Int, take: Int, where: PriceMapWhereInput): [PriceMap!]!
  purchase(where: PurchaseWhereUniqueInput!): Purchase
  purchases(cursor: PurchaseWhereUniqueInput, distinct: [PurchaseScalarFieldEnum!], orderBy: [PurchaseOrderByWithRelationInput!], skip: Int, take: Int, where: PurchaseWhereInput): [Purchase!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum Rank {
  FIVE
  FOUR
  ONE
  THREE
  TWO
}

type Response {
  isSuccess: Boolean!
  message: String!
}

enum Role {
  ADMIN
  STAFF
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

"""
The javascript `Date` as integer. Type represents date and time as number of milliseconds from start of UNIX epoch.
"""
scalar Timestamp

type User {
  _count: UserCount
  createdAt: Timestamp!
  created_at: Timestamp!
  id: String!
  posts(cursor: PostWhereUniqueInput, distinct: [PostScalarFieldEnum!], orderBy: [PostOrderByWithRelationInput!], skip: Int, take: Int, where: PostWhereInput): [Post!]!
  profile: Person!
  role: Role!
  updatedAt: Timestamp!
  updated_at: Timestamp!
}

type UserCount {
  posts: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  password: Int!
  role: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  createdAt: Timestamp
  password: String!
  posts: PostCreateNestedManyWithoutAuthorInput
  profile: PersonCreateNestedOneWithoutUserInput!
  role: Role
  updatedAt: Timestamp
}

input UserCreateManyInput {
  createdAt: Timestamp
  id: String!
  password: String!
  role: Role
  updatedAt: Timestamp
}

input UserCreateNestedOneWithoutPostsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPostsInput
  create: UserCreateWithoutPostsInput
}

input UserCreateNestedOneWithoutProfileInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProfileInput
  create: UserCreateWithoutProfileInput
}

input UserCreateOrConnectWithoutPostsInput {
  create: UserCreateWithoutPostsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutProfileInput {
  create: UserCreateWithoutProfileInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutPostsInput {
  createdAt: Timestamp
  password: String!
  profile: PersonCreateNestedOneWithoutUserInput!
  role: Role
  updatedAt: Timestamp
}

input UserCreateWithoutProfileInput {
  createdAt: Timestamp
  password: String!
  posts: PostCreateNestedManyWithoutAuthorInput
  role: Role
  updatedAt: Timestamp
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  createdAt: Timestamp!
  id: String!
  password: String!
  role: Role!
  updatedAt: Timestamp!
}

type UserMaxAggregate {
  createdAt: Timestamp
  id: String
  password: String
  role: Role
  updatedAt: Timestamp
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  createdAt: Timestamp
  id: String
  password: String
  role: Role
  updatedAt: Timestamp
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  password: SortOrder
  posts: PostOrderByRelationAggregateInput
  profile: PersonOrderByWithRelationInput
  role: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  id
  password
  role
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  role: EnumRoleWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorInput
  profile: PersonUpdateOneRequiredWithoutUserInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutPostsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutPostsInput
  create: UserCreateWithoutPostsInput
  update: UserUpdateWithoutPostsInput
  upsert: UserUpsertWithoutPostsInput
}

input UserUpdateOneWithoutProfileInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProfileInput
  create: UserCreateWithoutProfileInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutProfileInput
  upsert: UserUpsertWithoutProfileInput
}

input UserUpdateWithoutPostsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  profile: PersonUpdateOneRequiredWithoutUserInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutProfileInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  posts: PostUpdateManyWithoutAuthorInput
  role: EnumRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutPostsInput {
  create: UserCreateWithoutPostsInput!
  update: UserUpdateWithoutPostsInput!
}

input UserUpsertWithoutProfileInput {
  create: UserCreateWithoutProfileInput!
  update: UserUpdateWithoutProfileInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  password: StringFilter
  posts: PostListRelationFilter
  profile: PersonRelationFilter
  role: EnumRoleFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  id: String
}
